// <auto-generated/>

//#region Object
declare namespace System {
	class Object {

		// Constructors:
		constructor();

		// Methods:
		ToString(): string | null;

		Equals(
			obj: any | null
		): boolean;

		static Equals(
			objA: any | null,
			objB: any | null
		): boolean;

		static ReferenceEquals(
			objA: any | null,
			objB: any | null
		): boolean;

		GetHashCode(): number;
	}
}
//#endregion

//#region Boolean
declare namespace System {
	class /* struct */ Boolean extends System.ValueType {
		// Declaration skipped
	}
}
//#endregion

//#region Byte
declare namespace System {
	class /* struct */ Byte extends System.ValueType {
		// Declaration skipped
	}
}
//#endregion

//#region SByte
declare namespace System {
	class /* struct */ SByte extends System.ValueType {
		// Declaration skipped
	}
}
//#endregion

//#region Int16
declare namespace System {
	class /* struct */ Int16 extends System.ValueType {
		// Declaration skipped
	}
}
//#endregion

//#region UInt16
declare namespace System {
	class /* struct */ UInt16 extends System.ValueType {
		// Declaration skipped
	}
}
//#endregion

//#region Int32
declare namespace System {
	class /* struct */ Int32 extends System.ValueType {
		// Declaration skipped
	}
}
//#endregion

//#region UInt32
declare namespace System {
	class /* struct */ UInt32 extends System.ValueType {
		// Declaration skipped
	}
}
//#endregion

//#region Int64
declare namespace System {
	class /* struct */ Int64 extends System.ValueType {
		// Declaration skipped
	}
}
//#endregion

//#region UInt64
declare namespace System {
	class /* struct */ UInt64 extends System.ValueType {
		// Declaration skipped
	}
}
//#endregion

//#region Single
declare namespace System {
	class /* struct */ Single extends System.ValueType {
		// Declaration skipped
	}
}
//#endregion

//#region Double
declare namespace System {
	class /* struct */ Double extends System.ValueType {
		// Declaration skipped
	}
}
//#endregion

//#region Decimal
declare namespace System {
	class /* struct */ Decimal extends System.ValueType {
		// Declaration skipped
	}
}
//#endregion

//#region Char
declare namespace System {
	class /* struct */ Char extends System.ValueType {
		// Declaration skipped
	}
}
//#endregion

//#region String
declare namespace System {
	class String extends System.Object {
		// Declaration skipped
	}
}
//#endregion

//#region Delegate
declare namespace System {
	// Declaration skipped: "Delegate"
}
//#endregion

//#region Action
declare namespace System {
	// Declaration skipped: "Action"
}
//#endregion

//#region Action_1
declare namespace System {
	// Declaration skipped: "Action_1<T>"
}
//#endregion

//#region Action_2
declare namespace System {
	// Declaration skipped: "Action_2<T1, T2>"
}
//#endregion

//#region Action_3
declare namespace System {
	// Declaration skipped: "Action_3<T1, T2, T3>"
}
//#endregion

//#region Action_4
declare namespace System {
	// Declaration skipped: "Action_4<T1, T2, T3, T4>"
}
//#endregion

//#region Func_0
declare namespace System {
	// Declaration skipped: "Func_0<TResult>"
}
//#endregion

//#region Func_1
declare namespace System {
	// Declaration skipped: "Func_1<T, TResult>"
}
//#endregion

//#region Func_2
declare namespace System {
	// Declaration skipped: "Func_2<T1, T2, TResult>"
}
//#endregion

//#region Func_3
declare namespace System {
	// Declaration skipped: "Func_3<T1, T2, T3, TResult>"
}
//#endregion

//#region Func_4
declare namespace System {
	// Declaration skipped: "Func_4<T1, T2, T3, T4, TResult>"
}
//#endregion

//#region Array
declare namespace System {
	abstract class Array extends System.Object
		implements
			System.Collections.IList,
			System.Collections.ICollection,
			System.Collections.IEnumerable
	{
		// Properties:
		readonly Length: number;
		readonly LongLength: number;
		readonly Rank: number;
		readonly SyncRoot: any;
		readonly IsReadOnly: boolean;
		readonly IsFixedSize: boolean;
		readonly IsSynchronized: boolean;
		static readonly MaxLength: number;
		readonly Count: number;

		// Indexer:
		readonly Item: $Indexer_Array;

		// Methods:
		static ConstrainedCopy(
			sourceArray: System.Array,
			sourceIndex: number,
			destinationArray: System.Array,
			destinationIndex: number,
			length: number
		): void;

		static Clear(
			array: System.Array
		): void;

		static Clear(
			array: System.Array,
			index: number,
			length: number
		): void;

		GetLength(
			dimension: number
		): number;

		GetUpperBound(
			dimension: number
		): number;

		GetLowerBound(
			dimension: number
		): number;

		Initialize(): void;

		static Resize<T>(
			$T: any,
			/*ref*/ array: T[],
			newSize: number
		): void;

		static Copy(
			sourceArray: System.Array,
			destinationArray: System.Array,
			length: number
		): void;

		static Copy(
			sourceArray: System.Array,
			sourceIndex: number,
			destinationArray: System.Array,
			destinationIndex: number,
			length: number
		): void;

		static Copy(
			sourceArray: System.Array,
			destinationArray: System.Array,
			length: number
		): void;

		static Copy(
			sourceArray: System.Array,
			sourceIndex: number,
			destinationArray: System.Array,
			destinationIndex: number,
			length: number
		): void;

		GetValue(
			indices: number[]
		): any | null;

		GetValue(
			index: number
		): any | null;

		GetValue(
			index1: number,
			index2: number
		): any | null;

		GetValue(
			index1: number,
			index2: number,
			index3: number
		): any | null;

		SetValue(
			value: any | null,
			index: number
		): void;

		SetValue(
			value: any | null,
			index1: number,
			index2: number
		): void;

		SetValue(
			value: any | null,
			index1: number,
			index2: number,
			index3: number
		): void;

		SetValue(
			value: any | null,
			indices: number[]
		): void;

		GetValue(
			index: number
		): any | null;

		GetValue(
			index1: number,
			index2: number
		): any | null;

		GetValue(
			index1: number,
			index2: number,
			index3: number
		): any | null;

		GetValue(
			indices: number[]
		): any | null;

		SetValue(
			value: any | null,
			index: number
		): void;

		SetValue(
			value: any | null,
			index1: number,
			index2: number
		): void;

		SetValue(
			value: any | null,
			index1: number,
			index2: number,
			index3: number
		): void;

		SetValue(
			value: any | null,
			indices: number[]
		): void;

		GetLongLength(
			dimension: number
		): number;

		Clone(): any;

		static BinarySearch(
			array: System.Array,
			value: any | null
		): number;

		static BinarySearch(
			array: System.Array,
			index: number,
			length: number,
			value: any | null
		): number;

		static BinarySearch<T>(
			$T: any,
			array: (T | null)[],
			value: T | null
		): number;

		static BinarySearch<T>(
			$T: any,
			array: (T | null)[],
			value: T | null,
			comparer: System.Collections.Generic.IComparer<T> | null
		): number;

		static BinarySearch<T>(
			$T: any,
			array: (T | null)[],
			index: number,
			length: number,
			value: T | null
		): number;

		static BinarySearch<T>(
			$T: any,
			array: (T | null)[],
			index: number,
			length: number,
			value: T | null,
			comparer: System.Collections.Generic.IComparer<T> | null
		): number;

		CopyTo(
			array: System.Array,
			index: number
		): void;

		CopyTo(
			array: System.Array,
			index: number
		): void;

		static Empty<T>(
			$T: any
		): (T | null)[];

		static Fill<T>(
			$T: any,
			array: (T | null)[],
			value: T | null
		): void;

		static Fill<T>(
			$T: any,
			array: (T | null)[],
			value: T | null,
			startIndex: number,
			count: number
		): void;

		static ForEach<T>(
			$T: any,
			array: (T | null)[],
			action: System.Action_1<T> | System.Action
		): void;

		static IndexOf(
			array: System.Array,
			value: any | null
		): number;

		static IndexOf(
			array: System.Array,
			value: any | null,
			startIndex: number
		): number;

		static IndexOf(
			array: System.Array,
			value: any | null,
			startIndex: number,
			count: number
		): number;

		static IndexOf<T>(
			$T: any,
			array: (T | null)[],
			value: T | null
		): number;

		static IndexOf<T>(
			$T: any,
			array: (T | null)[],
			value: T | null,
			startIndex: number
		): number;

		static IndexOf<T>(
			$T: any,
			array: (T | null)[],
			value: T | null,
			startIndex: number,
			count: number
		): number;

		static LastIndexOf(
			array: System.Array,
			value: any | null
		): number;

		static LastIndexOf(
			array: System.Array,
			value: any | null,
			startIndex: number
		): number;

		static LastIndexOf(
			array: System.Array,
			value: any | null,
			startIndex: number,
			count: number
		): number;

		static LastIndexOf<T>(
			$T: any,
			array: (T | null)[],
			value: T | null
		): number;

		static LastIndexOf<T>(
			$T: any,
			array: (T | null)[],
			value: T | null,
			startIndex: number
		): number;

		static LastIndexOf<T>(
			$T: any,
			array: (T | null)[],
			value: T | null,
			startIndex: number,
			count: number
		): number;

		static Reverse(
			array: System.Array
		): void;

		static Reverse(
			array: System.Array,
			index: number,
			length: number
		): void;

		static Reverse<T>(
			$T: any,
			array: (T | null)[]
		): void;

		static Reverse<T>(
			$T: any,
			array: (T | null)[],
			index: number,
			length: number
		): void;

		static Sort(
			array: System.Array
		): void;

		static Sort(
			keys: System.Array,
			items: System.Array | null
		): void;

		static Sort(
			array: System.Array,
			index: number,
			length: number
		): void;

		static Sort(
			keys: System.Array,
			items: System.Array | null,
			index: number,
			length: number
		): void;

		static Sort<T>(
			$T: any,
			array: (T | null)[]
		): void;

		static Sort<TKey, TValue>(
			$TKey: any,
			$TValue: any,
			keys: TKey[],
			items: TValue[]
		): void;

		static Sort<T>(
			$T: any,
			array: (T | null)[],
			index: number,
			length: number
		): void;

		static Sort<TKey, TValue>(
			$TKey: any,
			$TValue: any,
			keys: TKey[],
			items: TValue[],
			index: number,
			length: number
		): void;

		static Sort<T>(
			$T: any,
			array: (T | null)[],
			comparer: System.Collections.Generic.IComparer<T> | null
		): void;

		static Sort<TKey, TValue>(
			$TKey: any,
			$TValue: any,
			keys: TKey[],
			items: TValue[],
			comparer: System.Collections.Generic.IComparer<TKey> | null
		): void;

		static Sort<T>(
			$T: any,
			array: (T | null)[],
			index: number,
			length: number,
			comparer: System.Collections.Generic.IComparer<T> | null
		): void;

		static Sort<TKey, TValue>(
			$TKey: any,
			$TValue: any,
			keys: TKey[],
			items: TValue[],
			index: number,
			length: number,
			comparer: System.Collections.Generic.IComparer<TKey> | null
		): void;

		GetEnumerator(): System.Collections.IEnumerator;

		Add(
			value: any | null
		): number;

		Contains(
			value: any | null
		): boolean;

		Clear(): void;

		IndexOf(
			value: any | null
		): number;

		Insert(
			index: number,
			value: any | null
		): void;

		Remove(
			value: any | null
		): void;

		RemoveAt(
			index: number
		): void;

		// Dummy constructor for some magic:
		protected constructor(...dummy: any[]);
	}

	/** This service type explains ClearScript access to .Net indexers. */
	abstract class $Indexer_Array {
		/** [ index: number ] -> any */
		public get(
			index: number
		): any;

		/** [ index: number ] <- any */
		public set(
			index: number,
			value: any | null
		): void;
	}
}
//#endregion

//#region ConcurrentQueue
declare namespace System.Collections.Concurrent {
	class ConcurrentQueue<T> extends System.Object
		implements
			System.Collections.Generic.IEnumerable<T>,
			System.Collections.IEnumerable,
			System.Collections.ICollection,
			System.Collections.Generic.IReadOnlyCollection<T>
	{
		// Constructors:
		constructor(
			$T: any
		);

		constructor(
			$T: any,
			collection: System.Collections.Generic.IEnumerable<T>
		);

		// Properties:
		readonly IsEmpty: boolean;
		readonly Count: number;
		readonly SyncRoot: any;
		readonly IsSynchronized: boolean;

		// Methods:
		ToArray(): (T | null)[];

		CopyTo(
			array: (T | null)[],
			index: number
		): void;

		GetEnumerator(): System.Collections.Generic.IEnumerator<T>;

		Enqueue(
			item: T | null
		): void;

		TryDequeue(
			/*out*/ result: T | null
		): boolean;

		TryPeek(
			/*out*/ result: T | null
		): boolean;

		Clear(): void;

		GetEnumerator(): System.Collections.IEnumerator;

		CopyTo(
			array: System.Array,
			index: number
		): void;

		// Some generics magic for TypeScript:
		private $ConcurrentQueue_T: T;
	}
}
//#endregion

//#region Dictionary
declare namespace System.Collections.Generic {
	class Dictionary<TKey, TValue> extends System.Object
		implements
			System.Collections.Generic.IDictionary<TKey, TValue>,
			System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>,
			System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>,
			System.Collections.IEnumerable,
			System.Collections.IDictionary,
			System.Collections.ICollection,
			System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>,
			System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>
	{
		// Constructors:
		constructor(
			$TKey: any,
			$TValue: any
		);

		constructor(
			$TKey: any,
			$TValue: any,
			capacity: number
		);

		constructor(
			$TKey: any,
			$TValue: any,
			dictionary: System.Collections.Generic.IDictionary<TKey, TValue>
		);

		constructor(
			$TKey: any,
			$TValue: any,
			collection: System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>
		);

		// Properties:
		readonly Count: number;
		readonly Capacity: number;
		readonly Keys: System.Collections.Generic.Dictionary.KeyCollection<TKey, TValue>;
		readonly Values: System.Collections.Generic.Dictionary.ValueCollection<TKey, TValue>;
		readonly IsReadOnly: boolean;
		readonly IsFixedSize: boolean;
		readonly SyncRoot: any;
		readonly IsSynchronized: boolean;

		// Indexer:
		readonly Item: $Indexer_Dictionary<TKey, TValue>;

		// Methods:
		Add(
			key: TKey,
			value: TValue | null
		): void;

		Clear(): void;

		ContainsKey(
			key: TKey
		): boolean;

		ContainsValue(
			value: TValue | null
		): boolean;

		GetEnumerator(): System.Collections.Generic.Dictionary.Enumerator<TKey, TValue>;

		OnDeserialization(
			sender: any | null
		): void;

		Remove(
			key: TKey
		): boolean;

		Remove(
			key: TKey,
			/*out*/ value: TValue | null
		): boolean;

		TryGetValue(
			key: TKey,
			/*out*/ value: TValue | null
		): boolean;

		TryAdd(
			key: TKey,
			value: TValue | null
		): boolean;

		EnsureCapacity(
			capacity: number
		): number;

		TrimExcess(): void;

		TrimExcess(
			capacity: number
		): void;

		Add(
			keyValuePair: System.Collections.Generic.KeyValuePair<TKey, TValue>
		): void;

		Contains(
			keyValuePair: System.Collections.Generic.KeyValuePair<TKey, TValue>
		): boolean;

		CopyTo(
			array: System.Collections.Generic.KeyValuePair<TKey, TValue>[],
			index: number
		): void;

		Remove(
			keyValuePair: System.Collections.Generic.KeyValuePair<TKey, TValue>
		): boolean;

		GetEnumerator(): System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>>;

		GetEnumerator(): System.Collections.IEnumerator;

		Contains(
			key: any | null
		): boolean;

		Add(
			key: any | null,
			value: any | null
		): void;

		GetEnumerator(): System.Collections.IDictionaryEnumerator;

		Remove(
			key: any | null
		): void;

		CopyTo(
			array: System.Array,
			index: number
		): void;

		// Some generics magic for TypeScript:
		private $Dictionary_TKey: TKey;
		private $Dictionary_TValue: TValue;
	}

	/** This service type explains ClearScript access to .Net indexers. */
	abstract class $Indexer_Dictionary<TKey, TValue> {
		/** [ key: TKey ] -> TValue */
		public get(
			key: TKey
		): TValue | null;

		/** [ key: TKey ] <- TValue */
		public set(
			key: TKey,
			value: TValue | null
		): void;

		/** [ key: any ] -> any */
		public get(
			key: any | null
		): any;

		/** [ key: any ] <- any */
		public set(
			key: any | null,
			value: any | null
		): void;
	}
}
//#endregion

//#region Dictionary.Enumerator
declare namespace System.Collections.Generic.Dictionary {
	class /* struct */ Enumerator<TKey, TValue> extends System.ValueType
		implements
			System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>>,
			System.IDisposable,
			System.Collections.IEnumerator,
			System.Collections.IDictionaryEnumerator
	{
		// Properties:
		readonly Current: System.Collections.Generic.KeyValuePair<TKey, TValue>;
		readonly Key: any;
		readonly Value: any;

		// Methods:
		MoveNext(): boolean;

		Dispose(): void;

		Reset(): void;

		// Default parameterless constructor for value types
		constructor();

		// Some generics magic for TypeScript:
		private $Enumerator_TKey: TKey;
		private $Enumerator_TValue: TValue;
	}
}
//#endregion

//#region Dictionary.KeyCollection
declare namespace System.Collections.Generic.Dictionary {
	class KeyCollection<TKey, TValue> extends System.Object
		implements
			System.Collections.Generic.ICollection<TKey>,
			System.Collections.Generic.IEnumerable<TKey>,
			System.Collections.IEnumerable,
			System.Collections.ICollection,
			System.Collections.Generic.IReadOnlyCollection<TKey>
	{
		// Constructors:
		constructor(
			$TKey: any,
			$TValue: any,
			dictionary: System.Collections.Generic.Dictionary<TKey, TValue>
		);

		// Properties:
		readonly Count: number;
		readonly IsReadOnly: boolean;
		readonly SyncRoot: any;
		readonly IsSynchronized: boolean;

		// Methods:
		GetEnumerator(): System.Collections.Generic.Dictionary.KeyCollection.Enumerator<TKey, TValue>;

		CopyTo(
			array: TKey[],
			index: number
		): void;

		Contains(
			item: TKey | null
		): boolean;

		Add(
			item: TKey | null
		): void;

		Clear(): void;

		Remove(
			item: TKey | null
		): boolean;

		GetEnumerator(): System.Collections.Generic.IEnumerator<TKey>;

		GetEnumerator(): System.Collections.IEnumerator;

		CopyTo(
			array: System.Array,
			index: number
		): void;

		// Some generics magic for TypeScript:
		private $KeyCollection_TKey: TKey;
		private $KeyCollection_TValue: TValue;
	}
}
//#endregion

//#region Dictionary.KeyCollection.Enumerator
declare namespace System.Collections.Generic.Dictionary.KeyCollection {
	class /* struct */ Enumerator<TKey, TValue> extends System.ValueType
		implements
			System.Collections.Generic.IEnumerator<TKey>,
			System.IDisposable,
			System.Collections.IEnumerator
	{
		// Properties:
		readonly Current: TKey;

		// Methods:
		Dispose(): void;

		MoveNext(): boolean;

		Reset(): void;

		// Default parameterless constructor for value types
		constructor();

		// Some generics magic for TypeScript:
		private $Enumerator_TKey: TKey;
		private $Enumerator_TValue: TValue;
	}
}
//#endregion

//#region Dictionary.ValueCollection
declare namespace System.Collections.Generic.Dictionary {
	class ValueCollection<TKey, TValue> extends System.Object
		implements
			System.Collections.Generic.ICollection<TValue>,
			System.Collections.Generic.IEnumerable<TValue>,
			System.Collections.IEnumerable,
			System.Collections.ICollection,
			System.Collections.Generic.IReadOnlyCollection<TValue>
	{
		// Constructors:
		constructor(
			$TKey: any,
			$TValue: any,
			dictionary: System.Collections.Generic.Dictionary<TKey, TValue>
		);

		// Properties:
		readonly Count: number;
		readonly IsReadOnly: boolean;
		readonly SyncRoot: any;
		readonly IsSynchronized: boolean;

		// Methods:
		GetEnumerator(): System.Collections.Generic.Dictionary.ValueCollection.Enumerator<TKey, TValue>;

		CopyTo(
			array: (TValue | null)[],
			index: number
		): void;

		Add(
			item: TValue | null
		): void;

		Clear(): void;

		Contains(
			item: TValue | null
		): boolean;

		Remove(
			item: TValue | null
		): boolean;

		GetEnumerator(): System.Collections.Generic.IEnumerator<TValue>;

		GetEnumerator(): System.Collections.IEnumerator;

		CopyTo(
			array: System.Array,
			index: number
		): void;

		// Some generics magic for TypeScript:
		private $ValueCollection_TKey: TKey;
		private $ValueCollection_TValue: TValue;
	}
}
//#endregion

//#region Dictionary.ValueCollection.Enumerator
declare namespace System.Collections.Generic.Dictionary.ValueCollection {
	class /* struct */ Enumerator<TKey, TValue> extends System.ValueType
		implements
			System.Collections.Generic.IEnumerator<TValue>,
			System.IDisposable,
			System.Collections.IEnumerator
	{
		// Properties:
		readonly Current: TValue | null;

		// Methods:
		Dispose(): void;

		MoveNext(): boolean;

		Reset(): void;

		// Default parameterless constructor for value types
		constructor();

		// Some generics magic for TypeScript:
		private $Enumerator_TKey: TKey;
		private $Enumerator_TValue: TValue;
	}
}
//#endregion

//#region HashSet
declare namespace System.Collections.Generic {
	class HashSet<T> extends System.Object
		implements
			System.Collections.Generic.ICollection<T>,
			System.Collections.Generic.IEnumerable<T>,
			System.Collections.IEnumerable,
			System.Collections.Generic.ISet<T>,
			System.Collections.Generic.IReadOnlyCollection<T>,
			System.Collections.Generic.IReadOnlySet<T>
	{
		// Constructors:
		constructor(
			$T: any
		);

		constructor(
			$T: any,
			capacity: number
		);

		constructor(
			$T: any,
			collection: System.Collections.Generic.IEnumerable<T>
		);

		// Properties:
		readonly Count: number;
		readonly Capacity: number;
		readonly IsReadOnly: boolean;

		// Methods:
		Clear(): void;

		Contains(
			item: T | null
		): boolean;

		Remove(
			item: T | null
		): boolean;

		GetEnumerator(): System.Collections.Generic.HashSet.Enumerator<T>;

		OnDeserialization(
			sender: any | null
		): void;

		Add(
			item: T | null
		): boolean;

		TryGetValue(
			equalValue: T | null,
			/*out*/ actualValue: T | null
		): boolean;

		UnionWith(
			other: System.Collections.Generic.IEnumerable<T>
		): void;

		IntersectWith(
			other: System.Collections.Generic.IEnumerable<T>
		): void;

		ExceptWith(
			other: System.Collections.Generic.IEnumerable<T>
		): void;

		SymmetricExceptWith(
			other: System.Collections.Generic.IEnumerable<T>
		): void;

		IsSubsetOf(
			other: System.Collections.Generic.IEnumerable<T>
		): boolean;

		IsProperSubsetOf(
			other: System.Collections.Generic.IEnumerable<T>
		): boolean;

		IsSupersetOf(
			other: System.Collections.Generic.IEnumerable<T>
		): boolean;

		IsProperSupersetOf(
			other: System.Collections.Generic.IEnumerable<T>
		): boolean;

		Overlaps(
			other: System.Collections.Generic.IEnumerable<T>
		): boolean;

		SetEquals(
			other: System.Collections.Generic.IEnumerable<T>
		): boolean;

		CopyTo(
			array: (T | null)[]
		): void;

		CopyTo(
			array: (T | null)[],
			arrayIndex: number
		): void;

		CopyTo(
			array: (T | null)[],
			arrayIndex: number,
			count: number
		): void;

		EnsureCapacity(
			capacity: number
		): number;

		TrimExcess(): void;

		TrimExcess(
			capacity: number
		): void;

		Add(
			item: T | null
		): void;

		GetEnumerator(): System.Collections.Generic.IEnumerator<T>;

		GetEnumerator(): System.Collections.IEnumerator;

		// Some generics magic for TypeScript:
		private $HashSet_T: T;
	}
}
//#endregion

//#region HashSet.Enumerator
declare namespace System.Collections.Generic.HashSet {
	class /* struct */ Enumerator<T> extends System.ValueType
		implements
			System.Collections.Generic.IEnumerator<T>,
			System.IDisposable,
			System.Collections.IEnumerator
	{
		// Properties:
		readonly Current: T | null;

		// Methods:
		MoveNext(): boolean;

		Dispose(): void;

		Reset(): void;

		// Default parameterless constructor for value types
		constructor();

		// Some generics magic for TypeScript:
		private $Enumerator_T: T;
	}
}
//#endregion

//#region ICollection
declare namespace System.Collections.Generic {
	interface ICollection<T> {

		// Properties:
		readonly Count: number;
		readonly IsReadOnly: boolean;

		// Methods:
		Add(
			item: T | null
		): void;

		Clear(): void;

		Contains(
			item: T | null
		): boolean;

		CopyTo(
			array: (T | null)[],
			arrayIndex: number
		): void;

		Remove(
			item: T | null
		): boolean;

		GetEnumerator(): System.Collections.Generic.IEnumerator<T>;

		GetEnumerator(): System.Collections.IEnumerator;
	}
	/** TypeScript type stub for .Net interface */
	abstract class ICollection<T> {}
}
//#endregion

//#region IComparer
declare namespace System.Collections.Generic {
	interface IComparer<T> {

		// Methods:
		Compare(
			x: T | null,
			y: T | null
		): number;
	}
	/** TypeScript type stub for .Net interface */
	abstract class IComparer<T> {}
}
//#endregion

//#region IDictionary
declare namespace System.Collections.Generic {
	interface IDictionary<TKey, TValue> {

		// Properties:
		readonly Keys: System.Collections.Generic.ICollection<TKey>;
		readonly Values: System.Collections.Generic.ICollection<TValue>;
		readonly Count: number;
		readonly IsReadOnly: boolean;

		// Indexer:
		readonly Item: $Indexer_IDictionary<TKey, TValue>;

		// Methods:
		ContainsKey(
			key: TKey | null
		): boolean;

		Add(
			key: TKey | null,
			value: TValue | null
		): void;

		Remove(
			key: TKey | null
		): boolean;

		TryGetValue(
			key: TKey | null,
			/*out*/ value: TValue | null
		): boolean;

		Add(
			item: System.Collections.Generic.KeyValuePair<TKey, TValue>
		): void;

		Clear(): void;

		Contains(
			item: System.Collections.Generic.KeyValuePair<TKey, TValue>
		): boolean;

		CopyTo(
			array: System.Collections.Generic.KeyValuePair<TKey, TValue>[],
			arrayIndex: number
		): void;

		Remove(
			item: System.Collections.Generic.KeyValuePair<TKey, TValue>
		): boolean;

		GetEnumerator(): System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>>;

		GetEnumerator(): System.Collections.IEnumerator;
	}
	/** TypeScript type stub for .Net interface */
	abstract class IDictionary<TKey, TValue> {}

	/** This service type explains ClearScript access to .Net indexers. */
	abstract class $Indexer_IDictionary<TKey, TValue> {
		/** [ key: TKey ] -> TValue */
		public get(
			key: TKey | null
		): TValue | null;

		/** [ key: TKey ] <- TValue */
		public set(
			key: TKey | null,
			value: TValue | null
		): void;
	}
}
//#endregion

//#region IEnumerable
declare namespace System.Collections.Generic {
	interface IEnumerable<T> {

		// Methods:
		GetEnumerator(): System.Collections.Generic.IEnumerator<T>;

		GetEnumerator(): System.Collections.IEnumerator;
	}
	/** TypeScript type stub for .Net interface */
	abstract class IEnumerable<T> {}
}
//#endregion

//#region IEnumerator
declare namespace System.Collections.Generic {
	interface IEnumerator<T> {

		// Properties:
		readonly Current: T | null;

		// Methods:
		Dispose(): void;

		MoveNext(): boolean;

		Reset(): void;
	}
	/** TypeScript type stub for .Net interface */
	abstract class IEnumerator<T> {}
}
//#endregion

//#region IList
declare namespace System.Collections.Generic {
	interface IList<T> {

		// Properties:
		readonly Count: number;
		readonly IsReadOnly: boolean;

		// Indexer:
		readonly Item: $Indexer_IList<T>;

		// Methods:
		IndexOf(
			item: T | null
		): number;

		Insert(
			index: number,
			item: T | null
		): void;

		RemoveAt(
			index: number
		): void;

		Add(
			item: T | null
		): void;

		Clear(): void;

		Contains(
			item: T | null
		): boolean;

		CopyTo(
			array: (T | null)[],
			arrayIndex: number
		): void;

		Remove(
			item: T | null
		): boolean;

		GetEnumerator(): System.Collections.Generic.IEnumerator<T>;

		GetEnumerator(): System.Collections.IEnumerator;
	}
	/** TypeScript type stub for .Net interface */
	abstract class IList<T> {}

	/** This service type explains ClearScript access to .Net indexers. */
	abstract class $Indexer_IList<T> {
		/** [ index: number ] -> T */
		public get(
			index: number
		): T | null;

		/** [ index: number ] <- T */
		public set(
			index: number,
			value: T | null
		): void;
	}
}
//#endregion

//#region IReadOnlyCollection
declare namespace System.Collections.Generic {
	interface IReadOnlyCollection<T> {

		// Properties:
		readonly Count: number;

		// Methods:
		GetEnumerator(): System.Collections.Generic.IEnumerator<T>;

		GetEnumerator(): System.Collections.IEnumerator;
	}
	/** TypeScript type stub for .Net interface */
	abstract class IReadOnlyCollection<T> {}
}
//#endregion

//#region IReadOnlyDictionary
declare namespace System.Collections.Generic {
	interface IReadOnlyDictionary<TKey, TValue> {

		// Properties:
		readonly Keys: System.Collections.Generic.IEnumerable<TKey>;
		readonly Values: System.Collections.Generic.IEnumerable<TValue>;
		readonly Count: number;

		// Indexer:
		readonly Item: $Indexer_IReadOnlyDictionary<TKey, TValue>;

		// Methods:
		ContainsKey(
			key: TKey | null
		): boolean;

		TryGetValue(
			key: TKey | null,
			/*out*/ value: TValue | null
		): boolean;

		GetEnumerator(): System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>>;

		GetEnumerator(): System.Collections.IEnumerator;
	}
	/** TypeScript type stub for .Net interface */
	abstract class IReadOnlyDictionary<TKey, TValue> {}

	/** This service type explains ClearScript access to .Net indexers. */
	abstract class $Indexer_IReadOnlyDictionary<TKey, TValue> {
		/** [ key: TKey ] -> TValue */
		public get(
			key: TKey | null
		): TValue | null;
	}
}
//#endregion

//#region IReadOnlyList
declare namespace System.Collections.Generic {
	interface IReadOnlyList<T> {

		// Properties:
		readonly Count: number;

		// Indexer:
		readonly Item: $Indexer_IReadOnlyList<T>;

		// Methods:
		GetEnumerator(): System.Collections.Generic.IEnumerator<T>;

		GetEnumerator(): System.Collections.IEnumerator;
	}
	/** TypeScript type stub for .Net interface */
	abstract class IReadOnlyList<T> {}

	/** This service type explains ClearScript access to .Net indexers. */
	abstract class $Indexer_IReadOnlyList<T> {
		/** [ index: number ] -> T */
		public get(
			index: number
		): T | null;
	}
}
//#endregion

//#region IReadOnlySet
declare namespace System.Collections.Generic {
	interface IReadOnlySet<T> {

		// Properties:
		readonly Count: number;

		// Methods:
		Contains(
			item: T | null
		): boolean;

		IsProperSubsetOf(
			other: System.Collections.Generic.IEnumerable<T>
		): boolean;

		IsProperSupersetOf(
			other: System.Collections.Generic.IEnumerable<T>
		): boolean;

		IsSubsetOf(
			other: System.Collections.Generic.IEnumerable<T>
		): boolean;

		IsSupersetOf(
			other: System.Collections.Generic.IEnumerable<T>
		): boolean;

		Overlaps(
			other: System.Collections.Generic.IEnumerable<T>
		): boolean;

		SetEquals(
			other: System.Collections.Generic.IEnumerable<T>
		): boolean;

		GetEnumerator(): System.Collections.Generic.IEnumerator<T>;

		GetEnumerator(): System.Collections.IEnumerator;
	}
	/** TypeScript type stub for .Net interface */
	abstract class IReadOnlySet<T> {}
}
//#endregion

//#region ISet
declare namespace System.Collections.Generic {
	interface ISet<T> {

		// Properties:
		readonly Count: number;
		readonly IsReadOnly: boolean;

		// Methods:
		Add(
			item: T | null
		): boolean;

		UnionWith(
			other: System.Collections.Generic.IEnumerable<T>
		): void;

		IntersectWith(
			other: System.Collections.Generic.IEnumerable<T>
		): void;

		ExceptWith(
			other: System.Collections.Generic.IEnumerable<T>
		): void;

		SymmetricExceptWith(
			other: System.Collections.Generic.IEnumerable<T>
		): void;

		IsSubsetOf(
			other: System.Collections.Generic.IEnumerable<T>
		): boolean;

		IsSupersetOf(
			other: System.Collections.Generic.IEnumerable<T>
		): boolean;

		IsProperSupersetOf(
			other: System.Collections.Generic.IEnumerable<T>
		): boolean;

		IsProperSubsetOf(
			other: System.Collections.Generic.IEnumerable<T>
		): boolean;

		Overlaps(
			other: System.Collections.Generic.IEnumerable<T>
		): boolean;

		SetEquals(
			other: System.Collections.Generic.IEnumerable<T>
		): boolean;

		Add(
			item: T | null
		): void;

		Clear(): void;

		Contains(
			item: T | null
		): boolean;

		CopyTo(
			array: (T | null)[],
			arrayIndex: number
		): void;

		Remove(
			item: T | null
		): boolean;

		GetEnumerator(): System.Collections.Generic.IEnumerator<T>;

		GetEnumerator(): System.Collections.IEnumerator;
	}
	/** TypeScript type stub for .Net interface */
	abstract class ISet<T> {}
}
//#endregion

//#region KeyValuePair
declare namespace System.Collections.Generic {
	class /* struct */ KeyValuePair<TKey, TValue> extends System.ValueType {

		// Constructors:
		constructor(
			$TKey: any,
			$TValue: any,
			key: TKey | null,
			value: TValue | null
		);

		// Properties:
		readonly Key: TKey | null;
		readonly Value: TValue | null;

		// Methods:
		Deconstruct(
			/*out*/ key: TKey | null,
			/*out*/ value: TValue | null
		): void;

		// Default parameterless constructor for value types
		constructor();

		// Some generics magic for TypeScript:
		private $KeyValuePair_TKey: TKey;
		private $KeyValuePair_TValue: TValue;
	}
}
//#endregion

//#region LinkedList
declare namespace System.Collections.Generic {
	class LinkedList<T> extends System.Object
		implements
			System.Collections.Generic.ICollection<T>,
			System.Collections.Generic.IEnumerable<T>,
			System.Collections.IEnumerable,
			System.Collections.ICollection,
			System.Collections.Generic.IReadOnlyCollection<T>
	{
		// Constructors:
		constructor(
			$T: any
		);

		constructor(
			$T: any,
			collection: System.Collections.Generic.IEnumerable<T>
		);

		// Properties:
		readonly Count: number;
		readonly IsReadOnly: boolean;
		readonly SyncRoot: any;
		readonly IsSynchronized: boolean;

		// Methods:
		Clear(): void;

		Contains(
			value: T | null
		): boolean;

		CopyTo(
			array: (T | null)[],
			index: number
		): void;

		GetEnumerator(): System.Collections.Generic.LinkedList.Enumerator<T>;

		Remove(
			value: T | null
		): boolean;

		RemoveFirst(): void;

		RemoveLast(): void;

		OnDeserialization(
			sender: any | null
		): void;

		Add(
			value: T | null
		): void;

		GetEnumerator(): System.Collections.Generic.IEnumerator<T>;

		GetEnumerator(): System.Collections.IEnumerator;

		CopyTo(
			array: System.Array,
			index: number
		): void;

		// Some generics magic for TypeScript:
		private $LinkedList_T: T;
	}
}
//#endregion

//#region LinkedList.Enumerator
declare namespace System.Collections.Generic.LinkedList {
	class /* struct */ Enumerator<T> extends System.ValueType
		implements
			System.Collections.Generic.IEnumerator<T>,
			System.IDisposable,
			System.Collections.IEnumerator
	{
		// Properties:
		readonly Current: T | null;

		// Methods:
		MoveNext(): boolean;

		Dispose(): void;

		Reset(): void;

		// Default parameterless constructor for value types
		constructor();

		// Some generics magic for TypeScript:
		private $Enumerator_T: T;
	}
}
//#endregion

//#region List
declare namespace System.Collections.Generic {
	class List<T> extends System.Object
		implements
			System.Collections.Generic.IList<T>,
			System.Collections.Generic.ICollection<T>,
			System.Collections.Generic.IEnumerable<T>,
			System.Collections.IEnumerable,
			System.Collections.IList,
			System.Collections.ICollection,
			System.Collections.Generic.IReadOnlyList<T>,
			System.Collections.Generic.IReadOnlyCollection<T>
	{
		// Constructors:
		constructor(
			$T: any
		);

		constructor(
			$T: any,
			capacity: number
		);

		constructor(
			$T: any,
			collection: System.Collections.Generic.IEnumerable<T>
		);

		// Properties:
		Capacity: number;
		readonly Count: number;
		readonly IsReadOnly: boolean;
		readonly IsFixedSize: boolean;
		readonly SyncRoot: any;
		readonly IsSynchronized: boolean;

		// Indexer:
		readonly Item: $Indexer_List<T>;

		// Methods:
		Add(
			item: T | null
		): void;

		AddRange(
			collection: System.Collections.Generic.IEnumerable<T>
		): void;

		BinarySearch(
			index: number,
			count: number,
			item: T | null,
			comparer: System.Collections.Generic.IComparer<T> | null
		): number;

		BinarySearch(
			item: T | null
		): number;

		BinarySearch(
			item: T | null,
			comparer: System.Collections.Generic.IComparer<T> | null
		): number;

		Clear(): void;

		Contains(
			item: T | null
		): boolean;

		CopyTo(
			array: (T | null)[]
		): void;

		CopyTo(
			index: number,
			array: (T | null)[],
			arrayIndex: number,
			count: number
		): void;

		CopyTo(
			array: (T | null)[],
			arrayIndex: number
		): void;

		EnsureCapacity(
			capacity: number
		): number;

		ForEach(
			action: System.Action_1<T> | System.Action
		): void;

		GetEnumerator(): System.Collections.Generic.List.Enumerator<T>;

		GetRange(
			index: number,
			count: number
		): System.Collections.Generic.List<T>;

		Slice(
			start: number,
			length: number
		): System.Collections.Generic.List<T>;

		IndexOf(
			item: T | null
		): number;

		IndexOf(
			item: T | null,
			index: number
		): number;

		IndexOf(
			item: T | null,
			index: number,
			count: number
		): number;

		Insert(
			index: number,
			item: T | null
		): void;

		InsertRange(
			index: number,
			collection: System.Collections.Generic.IEnumerable<T>
		): void;

		LastIndexOf(
			item: T | null
		): number;

		LastIndexOf(
			item: T | null,
			index: number
		): number;

		LastIndexOf(
			item: T | null,
			index: number,
			count: number
		): number;

		Remove(
			item: T | null
		): boolean;

		RemoveAt(
			index: number
		): void;

		RemoveRange(
			index: number,
			count: number
		): void;

		Reverse(): void;

		Reverse(
			index: number,
			count: number
		): void;

		Sort(): void;

		Sort(
			comparer: System.Collections.Generic.IComparer<T> | null
		): void;

		Sort(
			index: number,
			count: number,
			comparer: System.Collections.Generic.IComparer<T> | null
		): void;

		ToArray(): (T | null)[];

		TrimExcess(): void;

		GetEnumerator(): System.Collections.Generic.IEnumerator<T>;

		GetEnumerator(): System.Collections.IEnumerator;

		Add(
			item: any | null
		): number;

		Contains(
			item: any | null
		): boolean;

		IndexOf(
			item: any | null
		): number;

		Insert(
			index: number,
			item: any | null
		): void;

		Remove(
			item: any | null
		): void;

		CopyTo(
			array: System.Array,
			arrayIndex: number
		): void;

		// Some generics magic for TypeScript:
		private $List_T: T;
	}

	/** This service type explains ClearScript access to .Net indexers. */
	abstract class $Indexer_List<T> {
		/** [ index: number ] -> T */
		public get(
			index: number
		): T | null;

		/** [ index: number ] <- T */
		public set(
			index: number,
			value: T | null
		): void;

		/** [ index: number ] -> any */
		public get(
			index: number
		): any;

		/** [ index: number ] <- any */
		public set(
			index: number,
			value: any | null
		): void;
	}
}
//#endregion

//#region List.Enumerator
declare namespace System.Collections.Generic.List {
	class /* struct */ Enumerator<T> extends System.ValueType
		implements
			System.Collections.Generic.IEnumerator<T>,
			System.IDisposable,
			System.Collections.IEnumerator
	{
		// Properties:
		readonly Current: T | null;

		// Methods:
		Dispose(): void;

		MoveNext(): boolean;

		Reset(): void;

		// Default parameterless constructor for value types
		constructor();

		// Some generics magic for TypeScript:
		private $Enumerator_T: T;
	}
}
//#endregion

//#region OrderedDictionary.Enumerator
declare namespace System.Collections.Generic.OrderedDictionary {
	class /* struct */ Enumerator<TKey, TValue> extends System.ValueType
		implements
			System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>>,
			System.IDisposable,
			System.Collections.IEnumerator,
			System.Collections.IDictionaryEnumerator
	{
		// Properties:
		readonly Current: System.Collections.Generic.KeyValuePair<TKey, TValue>;
		readonly Key: any;
		readonly Value: any;

		// Methods:
		MoveNext(): boolean;

		Dispose(): void;

		Reset(): void;

		// Default parameterless constructor for value types
		constructor();

		// Some generics magic for TypeScript:
		private $Enumerator_TKey: TKey;
		private $Enumerator_TValue: TValue;
	}
}
//#endregion

//#region OrderedDictionary.KeyCollection.Enumerator
declare namespace System.Collections.Generic.OrderedDictionary.KeyCollection {
	class /* struct */ Enumerator<TKey, TValue> extends System.ValueType
		implements
			System.Collections.Generic.IEnumerator<TKey>,
			System.IDisposable,
			System.Collections.IEnumerator
	{
		// Properties:
		readonly Current: TKey;

		// Methods:
		MoveNext(): boolean;

		Dispose(): void;

		Reset(): void;

		// Default parameterless constructor for value types
		constructor();

		// Some generics magic for TypeScript:
		private $Enumerator_TKey: TKey;
		private $Enumerator_TValue: TValue;
	}
}
//#endregion

//#region OrderedDictionary.ValueCollection.Enumerator
declare namespace System.Collections.Generic.OrderedDictionary.ValueCollection {
	class /* struct */ Enumerator<TKey, TValue> extends System.ValueType
		implements
			System.Collections.Generic.IEnumerator<TValue>,
			System.IDisposable,
			System.Collections.IEnumerator
	{
		// Properties:
		readonly Current: TValue | null;

		// Methods:
		MoveNext(): boolean;

		Dispose(): void;

		Reset(): void;

		// Default parameterless constructor for value types
		constructor();

		// Some generics magic for TypeScript:
		private $Enumerator_TKey: TKey;
		private $Enumerator_TValue: TValue;
	}
}
//#endregion

//#region OrderedDictionary
declare namespace System.Collections.Generic {
	class OrderedDictionary<TKey, TValue> extends System.Object
		implements
			System.Collections.Generic.IDictionary<TKey, TValue>,
			System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>,
			System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>,
			System.Collections.IEnumerable,
			System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>,
			System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>,
			System.Collections.IDictionary,
			System.Collections.ICollection,
			System.Collections.Generic.IList<System.Collections.Generic.KeyValuePair<TKey, TValue>>,
			System.Collections.Generic.IReadOnlyList<System.Collections.Generic.KeyValuePair<TKey, TValue>>,
			System.Collections.IList
	{
		// Constructors:
		constructor(
			$TKey: any,
			$TValue: any
		);

		constructor(
			$TKey: any,
			$TValue: any,
			capacity: number
		);

		constructor(
			$TKey: any,
			$TValue: any,
			dictionary: System.Collections.Generic.IDictionary<TKey, TValue>
		);

		constructor(
			$TKey: any,
			$TValue: any,
			collection: System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>
		);

		// Properties:
		readonly Capacity: number;
		readonly Count: number;
		readonly Keys: System.Collections.Generic.OrderedDictionary.KeyCollection<TKey, TValue>;
		readonly Values: System.Collections.Generic.OrderedDictionary.ValueCollection<TKey, TValue>;
		readonly IsReadOnly: boolean;
		readonly IsFixedSize: boolean;
		readonly SyncRoot: any;
		readonly IsSynchronized: boolean;

		// Indexer:
		readonly Item: $Indexer_OrderedDictionary<TKey, TValue>;

		// Methods:
		Add(
			key: TKey,
			value: TValue | null
		): void;

		TryAdd(
			key: TKey,
			value: TValue | null
		): boolean;

		Clear(): void;

		ContainsKey(
			key: TKey
		): boolean;

		ContainsValue(
			value: TValue | null
		): boolean;

		GetAt(
			index: number
		): System.Collections.Generic.KeyValuePair<TKey, TValue>;

		IndexOf(
			key: TKey
		): number;

		Insert(
			index: number,
			key: TKey,
			value: TValue | null
		): void;

		Remove(
			key: TKey
		): boolean;

		Remove(
			key: TKey,
			/*out*/ value: TValue | null
		): boolean;

		RemoveAt(
			index: number
		): void;

		SetAt(
			index: number,
			value: TValue | null
		): void;

		SetAt(
			index: number,
			key: TKey,
			value: TValue | null
		): void;

		EnsureCapacity(
			capacity: number
		): number;

		TrimExcess(): void;

		TrimExcess(
			capacity: number
		): void;

		TryGetValue(
			key: TKey,
			/*out*/ value: TValue | null
		): boolean;

		GetEnumerator(): System.Collections.Generic.OrderedDictionary.Enumerator<TKey, TValue>;

		Add(
			item: System.Collections.Generic.KeyValuePair<TKey, TValue>
		): void;

		Contains(
			item: System.Collections.Generic.KeyValuePair<TKey, TValue>
		): boolean;

		CopyTo(
			array: System.Collections.Generic.KeyValuePair<TKey, TValue>[],
			arrayIndex: number
		): void;

		Remove(
			item: System.Collections.Generic.KeyValuePair<TKey, TValue>
		): boolean;

		GetEnumerator(): System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>>;

		GetEnumerator(): System.Collections.IEnumerator;

		Contains(
			key: any | null
		): boolean;

		Add(
			key: any | null,
			value: any | null
		): void;

		GetEnumerator(): System.Collections.IDictionaryEnumerator;

		Remove(
			key: any | null
		): void;

		CopyTo(
			array: System.Array,
			index: number
		): void;

		IndexOf(
			item: System.Collections.Generic.KeyValuePair<TKey, TValue>
		): number;

		Insert(
			index: number,
			item: System.Collections.Generic.KeyValuePair<TKey, TValue>
		): void;

		Add(
			value: any | null
		): number;

		Contains(
			value: any | null
		): boolean;

		IndexOf(
			value: any | null
		): number;

		Insert(
			index: number,
			value: any | null
		): void;

		Remove(
			value: any | null
		): void;

		// Some generics magic for TypeScript:
		private $OrderedDictionary_TKey: TKey;
		private $OrderedDictionary_TValue: TValue;
	}

	/** This service type explains ClearScript access to .Net indexers. */
	abstract class $Indexer_OrderedDictionary<TKey, TValue> {
		/** [ key: TKey ] -> TValue */
		public get(
			key: TKey
		): TValue | null;

		/** [ key: TKey ] <- TValue */
		public set(
			key: TKey,
			value: TValue | null
		): void;

		/** [ key: any ] -> any */
		public get(
			key: any | null
		): any;

		/** [ key: any ] <- any */
		public set(
			key: any | null,
			value: any | null
		): void;

		/** [ index: number ] -> KeyValuePair<TKey, TValue> */
		public get(
			index: number
		): System.Collections.Generic.KeyValuePair<TKey, TValue>;

		/** [ index: number ] <- KeyValuePair<TKey, TValue> */
		public set(
			index: number,
			value: System.Collections.Generic.KeyValuePair<TKey, TValue>
		): void;

		/** [ index: number ] -> any */
		public get(
			index: number
		): any;

		/** [ index: number ] <- any */
		public set(
			index: number,
			value: any | null
		): void;
	}
}
//#endregion

//#region OrderedDictionary.KeyCollection
declare namespace System.Collections.Generic.OrderedDictionary {
	class KeyCollection<TKey, TValue> extends System.Object
		implements
			System.Collections.Generic.IList<TKey>,
			System.Collections.Generic.ICollection<TKey>,
			System.Collections.Generic.IEnumerable<TKey>,
			System.Collections.IEnumerable,
			System.Collections.Generic.IReadOnlyList<TKey>,
			System.Collections.Generic.IReadOnlyCollection<TKey>,
			System.Collections.IList,
			System.Collections.ICollection
	{
		// Properties:
		readonly Count: number;
		readonly IsReadOnly: boolean;
		readonly IsFixedSize: boolean;
		readonly SyncRoot: any;
		readonly IsSynchronized: boolean;

		// Indexer:
		readonly Item: $Indexer_KeyCollection<TKey, TValue>;

		// Methods:
		Contains(
			key: TKey | null
		): boolean;

		CopyTo(
			array: TKey[],
			arrayIndex: number
		): void;

		GetEnumerator(): System.Collections.Generic.OrderedDictionary.KeyCollection.Enumerator<TKey, TValue>;

		IndexOf(
			item: TKey | null
		): number;

		Insert(
			index: number,
			item: TKey | null
		): void;

		RemoveAt(
			index: number
		): void;

		Add(
			item: TKey | null
		): void;

		Clear(): void;

		Remove(
			item: TKey | null
		): boolean;

		GetEnumerator(): System.Collections.Generic.IEnumerator<TKey>;

		GetEnumerator(): System.Collections.IEnumerator;

		Add(
			value: any | null
		): number;

		Contains(
			value: any | null
		): boolean;

		Clear(): void;

		IndexOf(
			value: any | null
		): number;

		Insert(
			index: number,
			value: any | null
		): void;

		Remove(
			value: any | null
		): void;

		RemoveAt(
			index: number
		): void;

		CopyTo(
			array: System.Array,
			index: number
		): void;

		// Some generics magic for TypeScript:
		private $KeyCollection_TKey: TKey;
		private $KeyCollection_TValue: TValue;
	}

	/** This service type explains ClearScript access to .Net indexers. */
	abstract class $Indexer_KeyCollection<TKey, TValue> {
		/** [ index: number ] -> TKey */
		public get(
			index: number
		): TKey;

		/** [ index: number ] <- TKey */
		public set(
			index: number,
			value: TKey | null
		): void;

		/** [ index: number ] -> any */
		public get(
			index: number
		): any;

		/** [ index: number ] <- any */
		public set(
			index: number,
			value: any | null
		): void;
	}
}
//#endregion

//#region OrderedDictionary.ValueCollection
declare namespace System.Collections.Generic.OrderedDictionary {
	class ValueCollection<TKey, TValue> extends System.Object
		implements
			System.Collections.Generic.IList<TValue>,
			System.Collections.Generic.ICollection<TValue>,
			System.Collections.Generic.IEnumerable<TValue>,
			System.Collections.IEnumerable,
			System.Collections.Generic.IReadOnlyList<TValue>,
			System.Collections.Generic.IReadOnlyCollection<TValue>,
			System.Collections.IList,
			System.Collections.ICollection
	{
		// Properties:
		readonly Count: number;
		readonly IsReadOnly: boolean;
		readonly IsFixedSize: boolean;
		readonly SyncRoot: any;
		readonly IsSynchronized: boolean;

		// Indexer:
		readonly Item: $Indexer_ValueCollection<TKey, TValue>;

		// Methods:
		CopyTo(
			array: (TValue | null)[],
			arrayIndex: number
		): void;

		GetEnumerator(): System.Collections.Generic.OrderedDictionary.ValueCollection.Enumerator<TKey, TValue>;

		IndexOf(
			item: TValue | null
		): number;

		Insert(
			index: number,
			item: TValue | null
		): void;

		RemoveAt(
			index: number
		): void;

		Add(
			item: TValue | null
		): void;

		Clear(): void;

		Contains(
			item: TValue | null
		): boolean;

		Remove(
			item: TValue | null
		): boolean;

		GetEnumerator(): System.Collections.Generic.IEnumerator<TValue>;

		GetEnumerator(): System.Collections.IEnumerator;

		Add(
			value: any | null
		): number;

		Contains(
			value: any | null
		): boolean;

		Clear(): void;

		IndexOf(
			value: any | null
		): number;

		Insert(
			index: number,
			value: any | null
		): void;

		Remove(
			value: any | null
		): void;

		RemoveAt(
			index: number
		): void;

		CopyTo(
			array: System.Array,
			index: number
		): void;

		// Some generics magic for TypeScript:
		private $ValueCollection_TKey: TKey;
		private $ValueCollection_TValue: TValue;
	}

	/** This service type explains ClearScript access to .Net indexers. */
	abstract class $Indexer_ValueCollection<TKey, TValue> {
		/** [ index: number ] -> TValue */
		public get(
			index: number
		): TValue;

		/** [ index: number ] <- TValue */
		public set(
			index: number,
			value: TValue | null
		): void;

		/** [ index: number ] -> any */
		public get(
			index: number
		): any;

		/** [ index: number ] <- any */
		public set(
			index: number,
			value: any | null
		): void;
	}
}
//#endregion

//#region ICollection
declare namespace System.Collections {
	interface ICollection {

		// Properties:
		readonly Count: number;
		readonly SyncRoot: any;
		readonly IsSynchronized: boolean;

		// Methods:
		CopyTo(
			array: System.Array,
			index: number
		): void;

		GetEnumerator(): System.Collections.IEnumerator;
	}
	/** TypeScript type stub for .Net interface */
	abstract class ICollection {}
}
//#endregion

//#region IDictionary
declare namespace System.Collections {
	interface IDictionary {

		// Properties:
		readonly Keys: System.Collections.ICollection;
		readonly Values: System.Collections.ICollection;
		readonly IsReadOnly: boolean;
		readonly IsFixedSize: boolean;
		readonly Count: number;
		readonly SyncRoot: any;
		readonly IsSynchronized: boolean;

		// Indexer:
		readonly Item: $Indexer_IDictionary;

		// Methods:
		Contains(
			key: any
		): boolean;

		Add(
			key: any,
			value: any | null
		): void;

		Clear(): void;

		GetEnumerator(): System.Collections.IDictionaryEnumerator;

		Remove(
			key: any
		): void;

		CopyTo(
			array: System.Array,
			index: number
		): void;

		GetEnumerator(): System.Collections.IEnumerator;
	}
	/** TypeScript type stub for .Net interface */
	abstract class IDictionary {}

	/** This service type explains ClearScript access to .Net indexers. */
	abstract class $Indexer_IDictionary {
		/** [ key: any ] -> any */
		public get(
			key: any
		): any | null;

		/** [ key: any ] <- any */
		public set(
			key: any,
			value: any | null
		): void;
	}
}
//#endregion

//#region IDictionaryEnumerator
declare namespace System.Collections {
	interface IDictionaryEnumerator {

		// Properties:
		readonly Key: any;
		readonly Value: any | null;
		readonly Current: any;

		// Methods:
		MoveNext(): boolean;

		Reset(): void;
	}
	/** TypeScript type stub for .Net interface */
	abstract class IDictionaryEnumerator {}
}
//#endregion

//#region IEnumerable
declare namespace System.Collections {
	interface IEnumerable {

		// Methods:
		GetEnumerator(): System.Collections.IEnumerator;
	}
	/** TypeScript type stub for .Net interface */
	abstract class IEnumerable {}
}
//#endregion

//#region IEnumerator
declare namespace System.Collections {
	interface IEnumerator {

		// Properties:
		readonly Current: any;

		// Methods:
		MoveNext(): boolean;

		Reset(): void;
	}
	/** TypeScript type stub for .Net interface */
	abstract class IEnumerator {}
}
//#endregion

//#region IList
declare namespace System.Collections {
	interface IList {

		// Properties:
		readonly IsReadOnly: boolean;
		readonly IsFixedSize: boolean;
		readonly Count: number;
		readonly SyncRoot: any;
		readonly IsSynchronized: boolean;

		// Indexer:
		readonly Item: $Indexer_IList;

		// Methods:
		Add(
			value: any | null
		): number;

		Contains(
			value: any | null
		): boolean;

		Clear(): void;

		IndexOf(
			value: any | null
		): number;

		Insert(
			index: number,
			value: any | null
		): void;

		Remove(
			value: any | null
		): void;

		RemoveAt(
			index: number
		): void;

		CopyTo(
			array: System.Array,
			index: number
		): void;

		GetEnumerator(): System.Collections.IEnumerator;
	}
	/** TypeScript type stub for .Net interface */
	abstract class IList {}

	/** This service type explains ClearScript access to .Net indexers. */
	abstract class $Indexer_IList {
		/** [ index: number ] -> any */
		public get(
			index: number
		): any | null;

		/** [ index: number ] <- any */
		public set(
			index: number,
			value: any | null
		): void;
	}
}
//#endregion

//#region ImmutableArray
declare namespace System.Collections.Immutable {
	class /* struct */ ImmutableArray<T> extends System.ValueType
		implements
			System.Collections.Generic.IReadOnlyList<T>,
			System.Collections.Generic.IReadOnlyCollection<T>,
			System.Collections.Generic.IEnumerable<T>,
			System.Collections.IEnumerable,
			System.Collections.Generic.IList<T>,
			System.Collections.Generic.ICollection<T>,
			System.IEquatable<System.Collections.Immutable.ImmutableArray<T>>,
			System.Collections.IList,
			System.Collections.ICollection
	{
		// Properties:
		readonly IsEmpty: boolean;
		readonly Length: number;
		readonly IsDefault: boolean;
		readonly IsDefaultOrEmpty: boolean;
		readonly Count: number;
		readonly IsReadOnly: boolean;
		readonly IsFixedSize: boolean;
		readonly SyncRoot: any;
		readonly IsSynchronized: boolean;

		// Indexer:
		readonly Item: $Indexer_ImmutableArray<T>;

		// Methods:
		IndexOf(
			item: T | null
		): number;

		IndexOf(
			item: T | null,
			startIndex: number
		): number;

		IndexOf(
			item: T | null,
			startIndex: number,
			count: number
		): number;

		LastIndexOf(
			item: T | null
		): number;

		LastIndexOf(
			item: T | null,
			startIndex: number
		): number;

		LastIndexOf(
			item: T | null,
			startIndex: number,
			count: number
		): number;

		Contains(
			item: T | null
		): boolean;

		Insert(
			index: number,
			item: T | null
		): System.Collections.Immutable.ImmutableArray<T>;

		InsertRange(
			index: number,
			items: System.Collections.Generic.IEnumerable<T>
		): System.Collections.Immutable.ImmutableArray<T>;

		InsertRange(
			index: number,
			items: System.Collections.Immutable.ImmutableArray<T>
		): System.Collections.Immutable.ImmutableArray<T>;

		Add(
			item: T | null
		): System.Collections.Immutable.ImmutableArray<T>;

		AddRange(
			items: System.Collections.Generic.IEnumerable<T>
		): System.Collections.Immutable.ImmutableArray<T>;

		AddRange(
			items: (T | null)[],
			length: number
		): System.Collections.Immutable.ImmutableArray<T>;

		AddRange<TDerived extends T>(
			$TDerived: T,
			items: TDerived[]
		): System.Collections.Immutable.ImmutableArray<T>;

		AddRange(
			items: System.Collections.Immutable.ImmutableArray<T>,
			length: number
		): System.Collections.Immutable.ImmutableArray<T>;

		AddRange<TDerived extends T>(
			$TDerived: T,
			items: System.Collections.Immutable.ImmutableArray<TDerived>
		): System.Collections.Immutable.ImmutableArray<T>;

		AddRange(
			items: System.Collections.Immutable.ImmutableArray<T>
		): System.Collections.Immutable.ImmutableArray<T>;

		SetItem(
			index: number,
			item: T | null
		): System.Collections.Immutable.ImmutableArray<T>;

		Replace(
			oldValue: T | null,
			newValue: T | null
		): System.Collections.Immutable.ImmutableArray<T>;

		Remove(
			item: T | null
		): System.Collections.Immutable.ImmutableArray<T>;

		RemoveAt(
			index: number
		): System.Collections.Immutable.ImmutableArray<T>;

		RemoveRange(
			index: number,
			length: number
		): System.Collections.Immutable.ImmutableArray<T>;

		RemoveRange(
			items: System.Collections.Generic.IEnumerable<T>
		): System.Collections.Immutable.ImmutableArray<T>;

		RemoveRange(
			items: System.Collections.Immutable.ImmutableArray<T>
		): System.Collections.Immutable.ImmutableArray<T>;

		Clear(): System.Collections.Immutable.ImmutableArray<T>;

		Sort(): System.Collections.Immutable.ImmutableArray<T>;

		Sort(
			comparer: System.Collections.Generic.IComparer<T> | null
		): System.Collections.Immutable.ImmutableArray<T>;

		Sort(
			index: number,
			count: number,
			comparer: System.Collections.Generic.IComparer<T> | null
		): System.Collections.Immutable.ImmutableArray<T>;

		OfType<TResult>(
			$TResult: any
		): System.Collections.Generic.IEnumerable<TResult>;

		AddRange(
			items: (T | null)[]
		): System.Collections.Immutable.ImmutableArray<T>;

		InsertRange(
			index: number,
			items: (T | null)[]
		): System.Collections.Immutable.ImmutableArray<T>;

		Slice(
			start: number,
			length: number
		): System.Collections.Immutable.ImmutableArray<T>;

		ItemRef(
			index: number
		): T | null;

		CopyTo(
			destination: (T | null)[]
		): void;

		CopyTo(
			destination: (T | null)[],
			destinationIndex: number
		): void;

		CopyTo(
			sourceIndex: number,
			destination: (T | null)[],
			destinationIndex: number,
			length: number
		): void;

		GetEnumerator(): System.Collections.Immutable.ImmutableArray.Enumerator<T>;

		Equals(
			other: System.Collections.Immutable.ImmutableArray<T>
		): boolean;

		CastArray<TOther>(
			$TOther: any
		): System.Collections.Immutable.ImmutableArray<TOther>;

		As<TOther>(
			$TOther: any
		): System.Collections.Immutable.ImmutableArray<TOther>;

		GetEnumerator(): System.Collections.Generic.IEnumerator<T>;

		GetEnumerator(): System.Collections.IEnumerator;

		Insert(
			index: number,
			item: T | null
		): void;

		RemoveAt(
			index: number
		): void;

		Add(
			item: T | null
		): void;

		Clear(): void;

		Remove(
			item: T | null
		): boolean;

		Add(
			value: any | null
		): number;

		Contains(
			value: any | null
		): boolean;

		Clear(): void;

		IndexOf(
			value: any | null
		): number;

		Insert(
			index: number,
			value: any | null
		): void;

		Remove(
			value: any | null
		): void;

		RemoveAt(
			index: number
		): void;

		CopyTo(
			array: System.Array,
			index: number
		): void;

		// Default parameterless constructor for value types
		constructor();

		// Some generics magic for TypeScript:
		private $ImmutableArray_T: T;
	}

	/** This service type explains ClearScript access to .Net indexers. */
	abstract class $Indexer_ImmutableArray<T> {
		/** [ index: number ] -> T */
		public get(
			index: number
		): T | null;

		/** [ index: number ] -> any */
		public get(
			index: number
		): any;

		/** [ index: number ] <- any */
		public set(
			index: number,
			value: any | null
		): void;
	}
}
//#endregion

//#region ImmutableArray.Enumerator
declare namespace System.Collections.Immutable.ImmutableArray {
	class /* struct */ Enumerator<T> extends System.ValueType {

		// Properties:
		readonly Current: T | null;

		// Methods:
		MoveNext(): boolean;

		// Default parameterless constructor for value types
		constructor();

		// Some generics magic for TypeScript:
		private $Enumerator_T: T;
	}
}
//#endregion

//#region Collection
declare namespace System.Collections.ObjectModel {
	class Collection<T> extends System.Object
		implements
			System.Collections.Generic.IList<T>,
			System.Collections.Generic.ICollection<T>,
			System.Collections.Generic.IEnumerable<T>,
			System.Collections.IEnumerable,
			System.Collections.IList,
			System.Collections.ICollection,
			System.Collections.Generic.IReadOnlyList<T>,
			System.Collections.Generic.IReadOnlyCollection<T>
	{
		// Constructors:
		constructor(
			$T: any
		);

		constructor(
			$T: any,
			list: System.Collections.Generic.IList<T>
		);

		// Properties:
		readonly Count: number;
		readonly IsReadOnly: boolean;
		readonly IsFixedSize: boolean;
		readonly SyncRoot: any;
		readonly IsSynchronized: boolean;

		// Indexer:
		readonly Item: $Indexer_Collection<T>;

		// Methods:
		Add(
			item: T | null
		): void;

		Clear(): void;

		CopyTo(
			array: (T | null)[],
			index: number
		): void;

		Contains(
			item: T | null
		): boolean;

		GetEnumerator(): System.Collections.Generic.IEnumerator<T>;

		IndexOf(
			item: T | null
		): number;

		Insert(
			index: number,
			item: T | null
		): void;

		Remove(
			item: T | null
		): boolean;

		RemoveAt(
			index: number
		): void;

		GetEnumerator(): System.Collections.IEnumerator;

		Add(
			value: any | null
		): number;

		Contains(
			value: any | null
		): boolean;

		IndexOf(
			value: any | null
		): number;

		Insert(
			index: number,
			value: any | null
		): void;

		Remove(
			value: any | null
		): void;

		CopyTo(
			array: System.Array,
			index: number
		): void;

		// Some generics magic for TypeScript:
		private $Collection_T: T;
	}

	/** This service type explains ClearScript access to .Net indexers. */
	abstract class $Indexer_Collection<T> {
		/** [ index: number ] -> T */
		public get(
			index: number
		): T | null;

		/** [ index: number ] <- T */
		public set(
			index: number,
			value: T | null
		): void;

		/** [ index: number ] -> any */
		public get(
			index: number
		): any;

		/** [ index: number ] <- any */
		public set(
			index: number,
			value: any | null
		): void;
	}
}
//#endregion

//#region ReadOnlyDictionary
declare namespace System.Collections.ObjectModel {
	class ReadOnlyDictionary<TKey, TValue> extends System.Object
		implements
			System.Collections.Generic.IDictionary<TKey, TValue>,
			System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>,
			System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>,
			System.Collections.IEnumerable,
			System.Collections.IDictionary,
			System.Collections.ICollection,
			System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>,
			System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>
	{
		// Constructors:
		constructor(
			$TKey: any,
			$TValue: any,
			dictionary: System.Collections.Generic.IDictionary<TKey, TValue>
		);

		// Properties:
		readonly Keys: System.Collections.ObjectModel.ReadOnlyDictionary.KeyCollection<TKey, TValue>;
		readonly Values: System.Collections.ObjectModel.ReadOnlyDictionary.ValueCollection<TKey, TValue>;
		readonly Count: number;
		readonly IsReadOnly: boolean;
		readonly IsFixedSize: boolean;
		readonly SyncRoot: any;
		readonly IsSynchronized: boolean;

		// Indexer:
		readonly Item: $Indexer_ReadOnlyDictionary<TKey, TValue>;

		// Methods:
		ContainsKey(
			key: TKey
		): boolean;

		TryGetValue(
			key: TKey,
			/*out*/ value: TValue | null
		): boolean;

		GetEnumerator(): System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>>;

		Add(
			key: TKey | null,
			value: TValue | null
		): void;

		Remove(
			key: TKey | null
		): boolean;

		Add(
			item: System.Collections.Generic.KeyValuePair<TKey, TValue>
		): void;

		Clear(): void;

		Contains(
			item: System.Collections.Generic.KeyValuePair<TKey, TValue>
		): boolean;

		CopyTo(
			array: System.Collections.Generic.KeyValuePair<TKey, TValue>[],
			arrayIndex: number
		): void;

		Remove(
			item: System.Collections.Generic.KeyValuePair<TKey, TValue>
		): boolean;

		GetEnumerator(): System.Collections.IEnumerator;

		Contains(
			key: any | null
		): boolean;

		Add(
			key: any | null,
			value: any | null
		): void;

		Clear(): void;

		GetEnumerator(): System.Collections.IDictionaryEnumerator;

		Remove(
			key: any | null
		): void;

		CopyTo(
			array: System.Array,
			index: number
		): void;

		// Some generics magic for TypeScript:
		private $ReadOnlyDictionary_TKey: TKey;
		private $ReadOnlyDictionary_TValue: TValue;
	}

	/** This service type explains ClearScript access to .Net indexers. */
	abstract class $Indexer_ReadOnlyDictionary<TKey, TValue> {
		/** [ key: TKey ] -> TValue */
		public get(
			key: TKey
		): TValue | null;

		/** [ key: any ] -> any */
		public get(
			key: any | null
		): any;

		/** [ key: any ] <- any */
		public set(
			key: any | null,
			value: any | null
		): void;
	}
}
//#endregion

//#region ReadOnlyDictionary.KeyCollection
declare namespace System.Collections.ObjectModel.ReadOnlyDictionary {
	class KeyCollection<TKey, TValue> extends System.Object
		implements
			System.Collections.Generic.ICollection<TKey>,
			System.Collections.Generic.IEnumerable<TKey>,
			System.Collections.IEnumerable,
			System.Collections.ICollection,
			System.Collections.Generic.IReadOnlyCollection<TKey>
	{
		// Properties:
		readonly Count: number;
		readonly IsReadOnly: boolean;
		readonly SyncRoot: any;
		readonly IsSynchronized: boolean;

		// Methods:
		Contains(
			item: TKey
		): boolean;

		CopyTo(
			array: TKey[],
			arrayIndex: number
		): void;

		GetEnumerator(): System.Collections.Generic.IEnumerator<TKey>;

		Add(
			item: TKey | null
		): void;

		Clear(): void;

		Remove(
			item: TKey | null
		): boolean;

		GetEnumerator(): System.Collections.IEnumerator;

		CopyTo(
			array: System.Array,
			index: number
		): void;

		// Some generics magic for TypeScript:
		private $KeyCollection_TKey: TKey;
		private $KeyCollection_TValue: TValue;
	}
}
//#endregion

//#region ReadOnlyDictionary.ValueCollection
declare namespace System.Collections.ObjectModel.ReadOnlyDictionary {
	class ValueCollection<TKey, TValue> extends System.Object
		implements
			System.Collections.Generic.ICollection<TValue>,
			System.Collections.Generic.IEnumerable<TValue>,
			System.Collections.IEnumerable,
			System.Collections.ICollection,
			System.Collections.Generic.IReadOnlyCollection<TValue>
	{
		// Properties:
		readonly Count: number;
		readonly IsReadOnly: boolean;
		readonly SyncRoot: any;
		readonly IsSynchronized: boolean;

		// Methods:
		CopyTo(
			array: (TValue | null)[],
			arrayIndex: number
		): void;

		GetEnumerator(): System.Collections.Generic.IEnumerator<TValue>;

		Add(
			item: TValue | null
		): void;

		Clear(): void;

		Contains(
			item: TValue | null
		): boolean;

		Remove(
			item: TValue | null
		): boolean;

		GetEnumerator(): System.Collections.IEnumerator;

		CopyTo(
			array: System.Array,
			index: number
		): void;

		// Some generics magic for TypeScript:
		private $ValueCollection_TKey: TKey;
		private $ValueCollection_TValue: TValue;
	}
}
//#endregion

//#region DateTime
declare namespace System {
	class /* struct */ DateTime extends System.ValueType
		implements
			System.IComparable<Date>,
			System.IEquatable<Date>
	{
		// Constructors:
		constructor(
			ticks: number
		);

		constructor(
			year: number,
			month: number,
			day: number
		);

		constructor(
			year: number,
			month: number,
			day: number,
			hour: number,
			minute: number,
			second: number
		);

		constructor(
			year: number,
			month: number,
			day: number,
			hour: number,
			minute: number,
			second: number,
			millisecond: number
		);

		constructor(
			year: number,
			month: number,
			day: number,
			hour: number,
			minute: number,
			second: number,
			millisecond: number,
			microsecond: number
		);

		// Fields:
		static readonly MinValue: Date;
		static readonly MaxValue: Date;
		static readonly UnixEpoch: Date;

		// Properties:
		readonly Date: Date;
		readonly Day: number;
		readonly DayOfYear: number;
		readonly Hour: number;
		readonly Millisecond: number;
		readonly Microsecond: number;
		readonly Nanosecond: number;
		readonly Minute: number;
		readonly Month: number;
		static readonly Now: Date;
		readonly Second: number;
		readonly Ticks: number;
		readonly TimeOfDay: string;
		static readonly Today: Date;
		readonly Year: number;
		static readonly UtcNow: Date;

		// Methods:
		Add(
			value: string
		): Date;

		AddDays(
			value: number
		): Date;

		AddHours(
			value: number
		): Date;

		AddMilliseconds(
			value: number
		): Date;

		AddMicroseconds(
			value: number
		): Date;

		AddMinutes(
			value: number
		): Date;

		AddMonths(
			months: number
		): Date;

		AddSeconds(
			value: number
		): Date;

		AddTicks(
			value: number
		): Date;

		AddYears(
			value: number
		): Date;

		static Compare(
			t1: Date,
			t2: Date
		): number;

		CompareTo(
			value: any | null
		): number;

		CompareTo(
			value: Date
		): number;

		static DaysInMonth(
			year: number,
			month: number
		): number;

		Equals(
			value: Date
		): boolean;

		static Equals(
			t1: Date,
			t2: Date
		): boolean;

		static FromBinary(
			dateData: number
		): Date;

		static FromFileTime(
			fileTime: number
		): Date;

		static FromFileTimeUtc(
			fileTime: number
		): Date;

		static FromOADate(
			d: number
		): Date;

		IsDaylightSavingTime(): boolean;

		ToBinary(): number;

		static IsLeapYear(
			year: number
		): boolean;

		static Parse(
			s: string
		): Date;

		Subtract(
			value: Date
		): string;

		Subtract(
			value: string
		): Date;

		ToOADate(): number;

		ToFileTime(): number;

		ToFileTimeUtc(): number;

		ToLocalTime(): Date;

		ToLongDateString(): string;

		ToLongTimeString(): string;

		ToShortDateString(): string;

		ToShortTimeString(): string;

		ToString(
			format: string | null
		): string;

		ToUniversalTime(): Date;

		static TryParse(
			s: string | null,
			/*out*/ result: Date
		): boolean;

		Deconstruct(
			/*out*/ year: number,
			/*out*/ month: number,
			/*out*/ day: number
		): void;

		GetDateTimeFormats(): string[];

		GetDateTimeFormats(
			format: string
		): string[];

		ToString(): string;

		// Default parameterless constructor for value types
		constructor();
	}
}
//#endregion

//#region Enum
declare namespace System {
	abstract class Enum
		extends System.ValueType
	{
		// Methods:
		static GetName<TEnum extends System.Enum & System.ValueType>(
			$TEnum: typeof System.Enum & typeof System.ValueType,
			value: TEnum
		): string | null;

		static GetNames<TEnum extends System.Enum & System.ValueType>(
			$TEnum: typeof System.Enum & typeof System.ValueType
		): string[];

		static GetValues<TEnum extends System.Enum & System.ValueType>(
			$TEnum: typeof System.Enum & typeof System.ValueType
		): TEnum[];

		static GetValuesAsUnderlyingType<TEnum extends System.Enum & System.ValueType>(
			$TEnum: typeof System.Enum & typeof System.ValueType
		): System.Array;

		HasFlag(
			flag: System.Enum
		): boolean;

		static IsDefined<TEnum extends System.Enum & System.ValueType>(
			$TEnum: typeof System.Enum & typeof System.ValueType,
			value: TEnum
		): boolean;

		static Parse<TEnum extends System.ValueType>(
			$TEnum: typeof System.ValueType,
			value: string
		): TEnum;

		static Parse<TEnum extends System.ValueType>(
			$TEnum: typeof System.ValueType,
			value: string,
			ignoreCase: boolean
		): TEnum;

		static TryParse<TEnum extends System.ValueType>(
			$TEnum: typeof System.ValueType,
			value: string | null,
			/*out*/ result: TEnum
		): boolean;

		static TryParse<TEnum extends System.ValueType>(
			$TEnum: typeof System.ValueType,
			value: string | null,
			ignoreCase: boolean,
			/*out*/ result: TEnum
		): boolean;

		CompareTo(
			target: any | null
		): number;

		ToString(
			format: string | null
		): string;

		ToString(): string;

		// Dummy constructor for some magic:
		protected constructor(...dummy: any[]);
	}
}
//#endregion

//#region EventArgs
declare namespace System {
	class EventArgs extends System.Object {

		// Constructors:
		constructor();

		// Fields:
		static readonly Empty: System.EventArgs;
	}
}
//#endregion

//#region EventHandler
declare namespace System {
	interface /* delegate */ EventHandler<TEventArgs> {
		(
			sender: any | null,
			e: TEventArgs | null
		): void;
	}
	/** TypeScript type stub for .Net delegate */
	class EventHandler<TEventArgs> { constructor(func: EventHandler<TEventArgs>); }
}
//#endregion

//#region Guid
declare namespace System {
	class /* struct */ Guid extends System.ValueType
		implements
			System.IComparable<string>,
			System.IEquatable<string>
	{
		// Constructors:
		constructor(
			b: number[]
		);

		constructor(
			a: number,
			b: number,
			c: number,
			d: number,
			e: number,
			f: number,
			g: number,
			h: number,
			i: number,
			j: number,
			k: number
		);

		constructor(
			a: number,
			b: number,
			c: number,
			d: number[]
		);

		constructor(
			a: number,
			b: number,
			c: number,
			d: number,
			e: number,
			f: number,
			g: number,
			h: number,
			i: number,
			j: number,
			k: number
		);

		constructor(
			g: string
		);

		// Fields:
		static readonly Empty: string;

		// Properties:
		static readonly AllBitsSet: string;
		readonly Variant: number;
		readonly Version: number;

		// Methods:
		static CreateVersion7(): string;

		static Parse(
			input: string
		): string;

		static TryParse(
			input: string | null,
			/*out*/ result: string
		): boolean;

		static ParseExact(
			input: string,
			format: string
		): string;

		static TryParseExact(
			input: string | null,
			format: string | null,
			/*out*/ result: string
		): boolean;

		ToByteArray(): number[];

		ToByteArray(
			bigEndian: boolean
		): number[];

		Equals(
			g: string
		): boolean;

		CompareTo(
			value: any | null
		): number;

		CompareTo(
			value: string
		): number;

		ToString(
			format: string | null
		): string;

		static NewGuid(): string;

		ToString(): string;

		// Default parameterless constructor for value types
		constructor();
	}
}
//#endregion

//#region IComparable
declare namespace System {
	interface IComparable<T> {

		// Methods:
		CompareTo(
			other: T | null
		): number;
	}
	/** TypeScript type stub for .Net interface */
	abstract class IComparable<T> {}
}
//#endregion

//#region IDisposable
declare namespace System {
	interface IDisposable {

		// Methods:
		Dispose(): void;
	}
	/** TypeScript type stub for .Net interface */
	abstract class IDisposable {}
}
//#endregion

//#region IEquatable
declare namespace System {
	interface IEquatable<T> {

		// Methods:
		Equals(
			other: T | null
		): boolean;
	}
	/** TypeScript type stub for .Net interface */
	abstract class IEquatable<T> {}
}
//#endregion

//#region BinaryReader
declare namespace System.IO {
	class BinaryReader extends System.Object
		implements System.IDisposable
	{
		// Constructors:
		constructor(
			input: System.IO.Stream
		);

		// Properties:
		readonly BaseStream: System.IO.Stream;

		// Methods:
		Dispose(): void;

		Close(): void;

		PeekChar(): number;

		Read(): number;

		ReadByte(): number;

		ReadSByte(): number;

		ReadBoolean(): boolean;

		ReadChar(): string;

		ReadInt16(): number;

		ReadUInt16(): number;

		ReadInt32(): number;

		ReadUInt32(): number;

		ReadInt64(): number;

		ReadUInt64(): number;

		ReadSingle(): number;

		ReadDouble(): number;

		ReadDecimal(): number;

		ReadString(): string;

		Read(
			buffer: string[],
			index: number,
			count: number
		): number;

		ReadChars(
			count: number
		): string[];

		Read(
			buffer: number[],
			index: number,
			count: number
		): number;

		ReadBytes(
			count: number
		): number[];

		Read7BitEncodedInt(): number;

		Read7BitEncodedInt64(): number;
	}
}
//#endregion

//#region BinaryWriter
declare namespace System.IO {
	class BinaryWriter extends System.Object
		implements System.IDisposable
	{
		// Constructors:
		constructor(
			output: System.IO.Stream
		);

		// Fields:
		static readonly Null: System.IO.BinaryWriter;

		// Properties:
		readonly BaseStream: System.IO.Stream;

		// Methods:
		Close(): void;

		Dispose(): void;

		Flush(): void;

		Write(
			value: boolean
		): void;

		Write(
			value: number
		): void;

		Write(
			value: number
		): void;

		Write(
			buffer: number[]
		): void;

		Write(
			buffer: number[],
			index: number,
			count: number
		): void;

		Write(
			ch: string
		): void;

		Write(
			chars: string[]
		): void;

		Write(
			chars: string[],
			index: number,
			count: number
		): void;

		Write(
			value: number
		): void;

		Write(
			value: number
		): void;

		Write(
			value: number
		): void;

		Write(
			value: number
		): void;

		Write(
			value: number
		): void;

		Write(
			value: number
		): void;

		Write(
			value: number
		): void;

		Write(
			value: number
		): void;

		Write(
			value: number
		): void;

		Write(
			value: string
		): void;

		Write7BitEncodedInt(
			value: number
		): void;

		Write7BitEncodedInt64(
			value: number
		): void;
	}
}
//#endregion

//#region Stream
declare namespace System.IO {
	abstract class Stream
		extends System.Object /* but real BaseType out of API */
		implements System.IDisposable
	{
		// Fields:
		static readonly Null: System.IO.Stream;

		// Properties:
		readonly CanRead: boolean;
		readonly CanWrite: boolean;
		readonly CanSeek: boolean;
		readonly CanTimeout: boolean;
		readonly Length: number;
		Position: number;
		ReadTimeout: number;
		WriteTimeout: number;

		// Methods:
		CopyTo(
			destination: System.IO.Stream
		): void;

		CopyTo(
			destination: System.IO.Stream,
			bufferSize: number
		): void;

		Dispose(): void;

		Close(): void;

		Flush(): void;

		SetLength(
			value: number
		): void;

		Read(
			buffer: number[],
			offset: number,
			count: number
		): number;

		ReadByte(): number;

		ReadExactly(
			buffer: number[],
			offset: number,
			count: number
		): void;

		Write(
			buffer: number[],
			offset: number,
			count: number
		): void;

		WriteByte(
			value: number
		): void;

		static Synchronized(
			stream: System.IO.Stream
		): System.IO.Stream;

		GetLifetimeService(): any;

		InitializeLifetimeService(): any;

		// Dummy constructor for some magic:
		protected constructor(...dummy: any[]);
	}
}
//#endregion

//#region ITuple
declare namespace System.Runtime.CompilerServices {
	interface ITuple {

		// Properties:
		readonly Length: number;

		// Indexer:
		readonly Item: $Indexer_ITuple;
	}
	/** TypeScript type stub for .Net interface */
	abstract class ITuple {}

	/** This service type explains ClearScript access to .Net indexers. */
	abstract class $Indexer_ITuple {
		/** [ index: number ] -> any */
		public get(
			index: number
		): any | null;
	}
}
//#endregion

//#region StringBuilder
declare namespace System.Text {
	class StringBuilder extends System.Object {

		// Constructors:
		constructor();

		constructor(
			capacity: number
		);

		constructor(
			value: string | null
		);

		constructor(
			value: string | null,
			capacity: number
		);

		constructor(
			value: string | null,
			startIndex: number,
			length: number,
			capacity: number
		);

		constructor(
			capacity: number,
			maxCapacity: number
		);

		// Properties:
		Capacity: number;
		readonly MaxCapacity: number;
		Length: number;

		// Indexer:
		readonly Item: $Indexer_StringBuilder;

		// Methods:
		EnsureCapacity(
			capacity: number
		): number;

		ToString(
			startIndex: number,
			length: number
		): string;

		Clear(): System.Text.StringBuilder;

		Append(
			value: string,
			repeatCount: number
		): System.Text.StringBuilder;

		Append(
			value: string[],
			startIndex: number,
			charCount: number
		): System.Text.StringBuilder;

		Append(
			value: string | null
		): System.Text.StringBuilder;

		Append(
			value: string | null,
			startIndex: number,
			count: number
		): System.Text.StringBuilder;

		Append(
			value: System.Text.StringBuilder | null
		): System.Text.StringBuilder;

		Append(
			value: System.Text.StringBuilder | null,
			startIndex: number,
			count: number
		): System.Text.StringBuilder;

		AppendLine(): System.Text.StringBuilder;

		AppendLine(
			value: string | null
		): System.Text.StringBuilder;

		CopyTo(
			sourceIndex: number,
			destination: string[],
			destinationIndex: number,
			count: number
		): void;

		Insert(
			index: number,
			value: string | null,
			count: number
		): System.Text.StringBuilder;

		Remove(
			startIndex: number,
			length: number
		): System.Text.StringBuilder;

		Append(
			value: boolean
		): System.Text.StringBuilder;

		Append(
			value: string
		): System.Text.StringBuilder;

		Append(
			value: number
		): System.Text.StringBuilder;

		Append(
			value: number
		): System.Text.StringBuilder;

		Append(
			value: number
		): System.Text.StringBuilder;

		Append(
			value: number
		): System.Text.StringBuilder;

		Append(
			value: number
		): System.Text.StringBuilder;

		Append(
			value: number
		): System.Text.StringBuilder;

		Append(
			value: number
		): System.Text.StringBuilder;

		Append(
			value: number
		): System.Text.StringBuilder;

		Append(
			value: number
		): System.Text.StringBuilder;

		Append(
			value: number
		): System.Text.StringBuilder;

		Append(
			value: number
		): System.Text.StringBuilder;

		Append(
			value: any | null
		): System.Text.StringBuilder;

		Append(
			value: string[]
		): System.Text.StringBuilder;

		AppendJoin(
			separator: string | null,
			values: (any | null)[]
		): System.Text.StringBuilder;

		AppendJoin<T>(
			$T: any,
			separator: string | null,
			values: System.Collections.Generic.IEnumerable<T>
		): System.Text.StringBuilder;

		AppendJoin(
			separator: string | null,
			values: (string | null)[]
		): System.Text.StringBuilder;

		AppendJoin(
			separator: string,
			values: (any | null)[]
		): System.Text.StringBuilder;

		AppendJoin<T>(
			$T: any,
			separator: string,
			values: System.Collections.Generic.IEnumerable<T>
		): System.Text.StringBuilder;

		AppendJoin(
			separator: string,
			values: (string | null)[]
		): System.Text.StringBuilder;

		Insert(
			index: number,
			value: string | null
		): System.Text.StringBuilder;

		Insert(
			index: number,
			value: boolean
		): System.Text.StringBuilder;

		Insert(
			index: number,
			value: number
		): System.Text.StringBuilder;

		Insert(
			index: number,
			value: number
		): System.Text.StringBuilder;

		Insert(
			index: number,
			value: number
		): System.Text.StringBuilder;

		Insert(
			index: number,
			value: string
		): System.Text.StringBuilder;

		Insert(
			index: number,
			value: string[]
		): System.Text.StringBuilder;

		Insert(
			index: number,
			value: string[],
			startIndex: number,
			charCount: number
		): System.Text.StringBuilder;

		Insert(
			index: number,
			value: number
		): System.Text.StringBuilder;

		Insert(
			index: number,
			value: number
		): System.Text.StringBuilder;

		Insert(
			index: number,
			value: number
		): System.Text.StringBuilder;

		Insert(
			index: number,
			value: number
		): System.Text.StringBuilder;

		Insert(
			index: number,
			value: number
		): System.Text.StringBuilder;

		Insert(
			index: number,
			value: number
		): System.Text.StringBuilder;

		Insert(
			index: number,
			value: number
		): System.Text.StringBuilder;

		Insert(
			index: number,
			value: number
		): System.Text.StringBuilder;

		Insert(
			index: number,
			value: any | null
		): System.Text.StringBuilder;

		AppendFormat(
			format: string,
			arg0: any | null
		): System.Text.StringBuilder;

		AppendFormat(
			format: string,
			arg0: any | null,
			arg1: any | null
		): System.Text.StringBuilder;

		AppendFormat(
			format: string,
			arg0: any | null,
			arg1: any | null,
			arg2: any | null
		): System.Text.StringBuilder;

		AppendFormat(
			format: string,
			args: (any | null)[]
		): System.Text.StringBuilder;

		Replace(
			oldValue: string,
			newValue: string | null
		): System.Text.StringBuilder;

		Equals(
			sb: System.Text.StringBuilder | null
		): boolean;

		Replace(
			oldValue: string,
			newValue: string | null,
			startIndex: number,
			count: number
		): System.Text.StringBuilder;

		Replace(
			oldChar: string,
			newChar: string
		): System.Text.StringBuilder;

		Replace(
			oldChar: string,
			newChar: string,
			startIndex: number,
			count: number
		): System.Text.StringBuilder;

		ToString(): string;
	}

	/** This service type explains ClearScript access to .Net indexers. */
	abstract class $Indexer_StringBuilder {
		/** [ index: number ] -> string */
		public get(
			index: number
		): string;

		/** [ index: number ] <- string */
		public set(
			index: number,
			value: string
		): void;
	}
}
//#endregion

//#region TimeSpan
declare namespace System {
	class /* struct */ TimeSpan extends System.ValueType
		implements
			System.IComparable<string>,
			System.IEquatable<string>
	{
		// Constructors:
		constructor(
			ticks: number
		);

		constructor(
			hours: number,
			minutes: number,
			seconds: number
		);

		constructor(
			days: number,
			hours: number,
			minutes: number,
			seconds: number
		);

		constructor(
			days: number,
			hours: number,
			minutes: number,
			seconds: number,
			milliseconds: number
		);

		constructor(
			days: number,
			hours: number,
			minutes: number,
			seconds: number,
			milliseconds: number,
			microseconds: number
		);

		// Fields:
		static readonly Zero: string;
		static readonly MaxValue: string;
		static readonly MinValue: string;
		static readonly /* const */ NanosecondsPerTick: number; // = 100
		static readonly /* const */ TicksPerMicrosecond: number; // = 10
		static readonly /* const */ TicksPerMillisecond: number; // = 10000
		static readonly /* const */ TicksPerSecond: number; // = 10000000
		static readonly /* const */ TicksPerMinute: number; // = 600000000
		static readonly /* const */ TicksPerHour: number; // = 36000000000
		static readonly /* const */ TicksPerDay: number; // = 864000000000
		static readonly /* const */ MicrosecondsPerMillisecond: number; // = 1000
		static readonly /* const */ MicrosecondsPerSecond: number; // = 1000000
		static readonly /* const */ MicrosecondsPerMinute: number; // = 60000000
		static readonly /* const */ MicrosecondsPerHour: number; // = 3600000000
		static readonly /* const */ MicrosecondsPerDay: number; // = 86400000000
		static readonly /* const */ MillisecondsPerSecond: number; // = 1000
		static readonly /* const */ MillisecondsPerMinute: number; // = 60000
		static readonly /* const */ MillisecondsPerHour: number; // = 3600000
		static readonly /* const */ MillisecondsPerDay: number; // = 86400000
		static readonly /* const */ SecondsPerMinute: number; // = 60
		static readonly /* const */ SecondsPerHour: number; // = 3600
		static readonly /* const */ SecondsPerDay: number; // = 86400
		static readonly /* const */ MinutesPerHour: number; // = 60
		static readonly /* const */ MinutesPerDay: number; // = 1440
		static readonly /* const */ HoursPerDay: number; // = 24

		// Properties:
		readonly Ticks: number;
		readonly Days: number;
		readonly Hours: number;
		readonly Milliseconds: number;
		readonly Microseconds: number;
		readonly Nanoseconds: number;
		readonly Minutes: number;
		readonly Seconds: number;
		readonly TotalDays: number;
		readonly TotalHours: number;
		readonly TotalMilliseconds: number;
		readonly TotalMicroseconds: number;
		readonly TotalNanoseconds: number;
		readonly TotalMinutes: number;
		readonly TotalSeconds: number;

		// Methods:
		Add(
			ts: string
		): string;

		static Compare(
			t1: string,
			t2: string
		): number;

		CompareTo(
			value: any | null
		): number;

		CompareTo(
			value: string
		): number;

		static FromDays(
			value: number
		): string;

		Duration(): string;

		Equals(
			obj: string
		): boolean;

		static Equals(
			t1: string,
			t2: string
		): boolean;

		static FromDays(
			days: number
		): string;

		static FromDays(
			days: number,
			hours?: number /* = 0 */,
			minutes?: number /* = 0 */,
			seconds?: number /* = 0 */,
			milliseconds?: number /* = 0 */,
			microseconds?: number /* = 0 */
		): string;

		static FromHours(
			hours: number
		): string;

		static FromHours(
			hours: number,
			minutes?: number /* = 0 */,
			seconds?: number /* = 0 */,
			milliseconds?: number /* = 0 */,
			microseconds?: number /* = 0 */
		): string;

		static FromMinutes(
			minutes: number
		): string;

		static FromMinutes(
			minutes: number,
			seconds?: number /* = 0 */,
			milliseconds?: number /* = 0 */,
			microseconds?: number /* = 0 */
		): string;

		static FromSeconds(
			seconds: number
		): string;

		static FromSeconds(
			seconds: number,
			milliseconds?: number /* = 0 */,
			microseconds?: number /* = 0 */
		): string;

		static FromMilliseconds(
			milliseconds: number,
			microseconds?: number /* = 0 */
		): string;

		static FromMicroseconds(
			microseconds: number
		): string;

		static FromHours(
			value: number
		): string;

		static FromMilliseconds(
			value: number
		): string;

		static FromMicroseconds(
			value: number
		): string;

		static FromMinutes(
			value: number
		): string;

		Negate(): string;

		static FromSeconds(
			value: number
		): string;

		Subtract(
			ts: string
		): string;

		Multiply(
			factor: number
		): string;

		Divide(
			divisor: number
		): string;

		Divide(
			ts: string
		): number;

		static FromTicks(
			value: number
		): string;

		static Parse(
			s: string
		): string;

		static TryParse(
			s: string | null,
			/*out*/ result: string
		): boolean;

		ToString(
			format: string | null
		): string;

		ToString(): string;

		// Default parameterless constructor for value types
		constructor();
	}
}
//#endregion

//#region Tuple
declare namespace System {
	class Tuple<T1, T2> extends System.Object
		implements System.Runtime.CompilerServices.ITuple
	{
		// Constructors:
		constructor(
			$T1: any,
			$T2: any,
			item1: T1 | null,
			item2: T2 | null
		);

		// Properties:
		readonly Item1: T1 | null;
		readonly Item2: T2 | null;
		readonly Length: number;

		// Indexer:
		readonly Item: $Indexer_Tuple<T1, T2>;

		// Some generics magic for TypeScript:
		private $Tuple_T1: T1;
		private $Tuple_T2: T2;
	}

	/** This service type explains ClearScript access to .Net indexers. */
	abstract class $Indexer_Tuple<T1, T2> {
		/** [ index: number ] -> any */
		public get(
			index: number
		): any;
	}
}
//#endregion

//#region ValueTuple
declare namespace System {
	class /* struct */ ValueTuple<T1, T2> extends System.ValueType
		implements
			System.IEquatable<System.ValueTuple<T1, T2>>,
			System.IComparable<System.ValueTuple<T1, T2>>,
			System.Runtime.CompilerServices.ITuple
	{
		// Constructors:
		constructor(
			$T1: any,
			$T2: any,
			item1: T1 | null,
			item2: T2 | null
		);

		// Fields:
		Item1: T1 | null;
		Item2: T2 | null;

		// Properties:
		readonly Length: number;

		// Indexer:
		readonly Item: $Indexer_ValueTuple<T1, T2>;

		// Methods:
		Equals(
			other: System.ValueTuple<T1, T2>
		): boolean;

		CompareTo(
			other: System.ValueTuple<T1, T2>
		): number;

		// Default parameterless constructor for value types
		constructor();

		// Some generics magic for TypeScript:
		private $ValueTuple_T1: T1;
		private $ValueTuple_T2: T2;
	}

	/** This service type explains ClearScript access to .Net indexers. */
	abstract class $Indexer_ValueTuple<T1, T2> {
		/** [ index: number ] -> any */
		public get(
			index: number
		): any;
	}
}
//#endregion

//#region ValueType
declare namespace System {
	abstract class ValueType extends System.Object {

		// Dummy constructor for some magic:
		protected constructor(...dummy: any[]);
	}
}
//#endregion

//#region Version
declare namespace System {
	class Version extends System.Object
		implements
			System.IComparable<System.Version>,
			System.IEquatable<System.Version>
	{
		// Constructors:
		constructor(
			major: number,
			minor: number,
			build: number,
			revision: number
		);

		constructor(
			major: number,
			minor: number,
			build: number
		);

		constructor(
			major: number,
			minor: number
		);

		constructor(
			version: string
		);

		constructor();

		// Properties:
		readonly Major: number;
		readonly Minor: number;
		readonly Build: number;
		readonly Revision: number;
		readonly MajorRevision: number;
		readonly MinorRevision: number;

		// Methods:
		Clone(): any;

		CompareTo(
			version: any | null
		): number;

		CompareTo(
			value: System.Version | null
		): number;

		Equals(
			obj: System.Version | null
		): boolean;

		ToString(
			fieldCount: number
		): string;

		static Parse(
			input: string
		): System.Version;

		static TryParse(
			input: string | null,
			/*out*/ result: System.Version | null
		): boolean;

		ToString(): string;
	}
}
//#endregion

//#region Types shorthand
// ----------------------------------------------------- //
// ---------========= Types shorthand =========--------- //
// ----------------------------------------------------- //
/*
export const Object = System.Object;
export type Object = System.Object;
export const Boolean = System.Boolean;
export type Boolean = System.Boolean;
export const Byte = System.Byte;
export type Byte = System.Byte;
export const SByte = System.SByte;
export type SByte = System.SByte;
export const Int16 = System.Int16;
export type Int16 = System.Int16;
export const UInt16 = System.UInt16;
export type UInt16 = System.UInt16;
export const Int32 = System.Int32;
export type Int32 = System.Int32;
export const UInt32 = System.UInt32;
export type UInt32 = System.UInt32;
export const Int64 = System.Int64;
export type Int64 = System.Int64;
export const UInt64 = System.UInt64;
export type UInt64 = System.UInt64;
export const Single = System.Single;
export type Single = System.Single;
export const Double = System.Double;
export type Double = System.Double;
export const Decimal = System.Decimal;
export type Decimal = System.Decimal;
export const Char = System.Char;
export type Char = System.Char;
export const String = System.String;
export type String = System.String;
export const Delegate = System.Delegate;
export type Delegate = System.Delegate;
export const Action = System.Action;
export type Action = System.Action;
export const Action_1 = System.Action_1;
export type Action_1<T> = System.Action_1<T>;
export const Action_2 = System.Action_2;
export type Action_2<T1, T2> = System.Action_2<T1, T2>;
export const Action_3 = System.Action_3;
export type Action_3<T1, T2, T3> = System.Action_3<T1, T2, T3>;
export const Action_4 = System.Action_4;
export type Action_4<T1, T2, T3, T4> = System.Action_4<T1, T2, T3, T4>;
export const Func_0 = System.Func_0;
export type Func_0<TResult> = System.Func_0<TResult>;
export const Func_1 = System.Func_1;
export type Func_1<T, TResult> = System.Func_1<T, TResult>;
export const Func_2 = System.Func_2;
export type Func_2<T1, T2, TResult> = System.Func_2<T1, T2, TResult>;
export const Func_3 = System.Func_3;
export type Func_3<T1, T2, T3, TResult> = System.Func_3<T1, T2, T3, TResult>;
export const Func_4 = System.Func_4;
export type Func_4<T1, T2, T3, T4, TResult> = System.Func_4<T1, T2, T3, T4, TResult>;
export const Array = System.Array;
export type Array = System.Array;
export const ConcurrentQueue = System.Collections.Concurrent.ConcurrentQueue;
export type ConcurrentQueue<T> = System.Collections.Concurrent.ConcurrentQueue<T>;
export const Dictionary = System.Collections.Generic.Dictionary;
export type Dictionary<TKey, TValue> = System.Collections.Generic.Dictionary<TKey, TValue>;
export const Enumerator = System.Collections.Generic.Dictionary.Enumerator;
export type Enumerator<TKey, TValue> = System.Collections.Generic.Dictionary.Enumerator<TKey, TValue>;
export const KeyCollection = System.Collections.Generic.Dictionary.KeyCollection;
export type KeyCollection<TKey, TValue> = System.Collections.Generic.Dictionary.KeyCollection<TKey, TValue>;
export const Enumerator = System.Collections.Generic.Dictionary.KeyCollection.Enumerator;
export type Enumerator<TKey, TValue> = System.Collections.Generic.Dictionary.KeyCollection.Enumerator<TKey, TValue>;
export const ValueCollection = System.Collections.Generic.Dictionary.ValueCollection;
export type ValueCollection<TKey, TValue> = System.Collections.Generic.Dictionary.ValueCollection<TKey, TValue>;
export const Enumerator = System.Collections.Generic.Dictionary.ValueCollection.Enumerator;
export type Enumerator<TKey, TValue> = System.Collections.Generic.Dictionary.ValueCollection.Enumerator<TKey, TValue>;
export const HashSet = System.Collections.Generic.HashSet;
export type HashSet<T> = System.Collections.Generic.HashSet<T>;
export const Enumerator = System.Collections.Generic.HashSet.Enumerator;
export type Enumerator<T> = System.Collections.Generic.HashSet.Enumerator<T>;
export const ICollection = System.Collections.Generic.ICollection;
export type ICollection<T> = System.Collections.Generic.ICollection<T>;
export const IComparer = System.Collections.Generic.IComparer;
export type IComparer<T> = System.Collections.Generic.IComparer<T>;
export const IDictionary = System.Collections.Generic.IDictionary;
export type IDictionary<TKey, TValue> = System.Collections.Generic.IDictionary<TKey, TValue>;
export const IEnumerable = System.Collections.Generic.IEnumerable;
export type IEnumerable<T> = System.Collections.Generic.IEnumerable<T>;
export const IEnumerator = System.Collections.Generic.IEnumerator;
export type IEnumerator<T> = System.Collections.Generic.IEnumerator<T>;
export const IList = System.Collections.Generic.IList;
export type IList<T> = System.Collections.Generic.IList<T>;
export const IReadOnlyCollection = System.Collections.Generic.IReadOnlyCollection;
export type IReadOnlyCollection<T> = System.Collections.Generic.IReadOnlyCollection<T>;
export const IReadOnlyDictionary = System.Collections.Generic.IReadOnlyDictionary;
export type IReadOnlyDictionary<TKey, TValue> = System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>;
export const IReadOnlyList = System.Collections.Generic.IReadOnlyList;
export type IReadOnlyList<T> = System.Collections.Generic.IReadOnlyList<T>;
export const IReadOnlySet = System.Collections.Generic.IReadOnlySet;
export type IReadOnlySet<T> = System.Collections.Generic.IReadOnlySet<T>;
export const ISet = System.Collections.Generic.ISet;
export type ISet<T> = System.Collections.Generic.ISet<T>;
export const KeyValuePair = System.Collections.Generic.KeyValuePair;
export type KeyValuePair<TKey, TValue> = System.Collections.Generic.KeyValuePair<TKey, TValue>;
export const LinkedList = System.Collections.Generic.LinkedList;
export type LinkedList<T> = System.Collections.Generic.LinkedList<T>;
export const Enumerator = System.Collections.Generic.LinkedList.Enumerator;
export type Enumerator<T> = System.Collections.Generic.LinkedList.Enumerator<T>;
export const List = System.Collections.Generic.List;
export type List<T> = System.Collections.Generic.List<T>;
export const Enumerator = System.Collections.Generic.List.Enumerator;
export type Enumerator<T> = System.Collections.Generic.List.Enumerator<T>;
export const Enumerator = System.Collections.Generic.OrderedDictionary.Enumerator;
export type Enumerator<TKey, TValue> = System.Collections.Generic.OrderedDictionary.Enumerator<TKey, TValue>;
export const Enumerator = System.Collections.Generic.OrderedDictionary.KeyCollection.Enumerator;
export type Enumerator<TKey, TValue> = System.Collections.Generic.OrderedDictionary.KeyCollection.Enumerator<TKey, TValue>;
export const Enumerator = System.Collections.Generic.OrderedDictionary.ValueCollection.Enumerator;
export type Enumerator<TKey, TValue> = System.Collections.Generic.OrderedDictionary.ValueCollection.Enumerator<TKey, TValue>;
export const OrderedDictionary = System.Collections.Generic.OrderedDictionary;
export type OrderedDictionary<TKey, TValue> = System.Collections.Generic.OrderedDictionary<TKey, TValue>;
export const KeyCollection = System.Collections.Generic.OrderedDictionary.KeyCollection;
export type KeyCollection<TKey, TValue> = System.Collections.Generic.OrderedDictionary.KeyCollection<TKey, TValue>;
export const ValueCollection = System.Collections.Generic.OrderedDictionary.ValueCollection;
export type ValueCollection<TKey, TValue> = System.Collections.Generic.OrderedDictionary.ValueCollection<TKey, TValue>;
export const ICollection = System.Collections.ICollection;
export type ICollection = System.Collections.ICollection;
export const IDictionary = System.Collections.IDictionary;
export type IDictionary = System.Collections.IDictionary;
export const IDictionaryEnumerator = System.Collections.IDictionaryEnumerator;
export type IDictionaryEnumerator = System.Collections.IDictionaryEnumerator;
export const IEnumerable = System.Collections.IEnumerable;
export type IEnumerable = System.Collections.IEnumerable;
export const IEnumerator = System.Collections.IEnumerator;
export type IEnumerator = System.Collections.IEnumerator;
export const IList = System.Collections.IList;
export type IList = System.Collections.IList;
export const ImmutableArray = System.Collections.Immutable.ImmutableArray;
export type ImmutableArray<T> = System.Collections.Immutable.ImmutableArray<T>;
export const Enumerator = System.Collections.Immutable.ImmutableArray.Enumerator;
export type Enumerator<T> = System.Collections.Immutable.ImmutableArray.Enumerator<T>;
export const Collection = System.Collections.ObjectModel.Collection;
export type Collection<T> = System.Collections.ObjectModel.Collection<T>;
export const ReadOnlyDictionary = System.Collections.ObjectModel.ReadOnlyDictionary;
export type ReadOnlyDictionary<TKey, TValue> = System.Collections.ObjectModel.ReadOnlyDictionary<TKey, TValue>;
export const KeyCollection = System.Collections.ObjectModel.ReadOnlyDictionary.KeyCollection;
export type KeyCollection<TKey, TValue> = System.Collections.ObjectModel.ReadOnlyDictionary.KeyCollection<TKey, TValue>;
export const ValueCollection = System.Collections.ObjectModel.ReadOnlyDictionary.ValueCollection;
export type ValueCollection<TKey, TValue> = System.Collections.ObjectModel.ReadOnlyDictionary.ValueCollection<TKey, TValue>;
export const DateTime = System.DateTime;
export type DateTime = System.DateTime;
export const Enum = System.Enum;
export type Enum = System.Enum;
export const EventArgs = System.EventArgs;
export type EventArgs = System.EventArgs;
export const EventHandler = System.EventHandler;
export type EventHandler<TEventArgs> = System.EventHandler<TEventArgs>;
export const Guid = System.Guid;
export type Guid = System.Guid;
export const IComparable = System.IComparable;
export type IComparable<T> = System.IComparable<T>;
export const IDisposable = System.IDisposable;
export type IDisposable = System.IDisposable;
export const IEquatable = System.IEquatable;
export type IEquatable<T> = System.IEquatable<T>;
export const BinaryReader = System.IO.BinaryReader;
export type BinaryReader = System.IO.BinaryReader;
export const BinaryWriter = System.IO.BinaryWriter;
export type BinaryWriter = System.IO.BinaryWriter;
export const Stream = System.IO.Stream;
export type Stream = System.IO.Stream;
export const ITuple = System.Runtime.CompilerServices.ITuple;
export type ITuple = System.Runtime.CompilerServices.ITuple;
export const StringBuilder = System.Text.StringBuilder;
export type StringBuilder = System.Text.StringBuilder;
export const TimeSpan = System.TimeSpan;
export type TimeSpan = System.TimeSpan;
export const Tuple = System.Tuple;
export type Tuple<T1, T2> = System.Tuple<T1, T2>;
export const ValueTuple = System.ValueTuple;
export type ValueTuple<T1, T2> = System.ValueTuple<T1, T2>;
export const ValueType = System.ValueType;
export type ValueType = System.ValueType;
export const Version = System.Version;
export type Version = System.Version;
*/
//#endregion
